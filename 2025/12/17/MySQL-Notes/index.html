

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/peach.png">
  <link rel="icon" href="/img/peach.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="mildempeach">
  <meta name="keywords" content="">
  
    <meta name="description" content="数据库：MySQL笔记 如题。  1. 数据库与MySQL基本概念1.1 数据库基本概念 数据库（DB，database）：数据存储的仓库，数据库又可以分为关系型数据库和非关系型数据库。 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 数据库管理系统（DBMS，database management system）：操纵和管理数据库的大型软件，包括Oracle、MySQL">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL-Notes">
<meta property="og:url" content="http://example.com/2025/12/17/MySQL-Notes/index.html">
<meta property="og:site_name">
<meta property="og:description" content="数据库：MySQL笔记 如题。  1. 数据库与MySQL基本概念1.1 数据库基本概念 数据库（DB，database）：数据存储的仓库，数据库又可以分为关系型数据库和非关系型数据库。 关系型数据库：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。 数据库管理系统（DBMS，database management system）：操纵和管理数据库的大型软件，包括Oracle、MySQL">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/MySQL-model.png">
<meta property="og:image" content="http://example.com/img%5CMySQL-Notes%5Cmulti-table-classify.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/MySQL-Ovierview.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/MySQL-engines.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/innodb-logic-store-structure.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/innodb-overview.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/innodb-page-structure.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/innodb-page.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/master-to-slave-copy-overview.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/master-to-slave-copy-demo-1.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/master-to-slave-copy-demo-2.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/master-to-slave-copy-demo-3.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/read-write-seperate-overview.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/read-write-seperate-overview.png">
<meta property="og:image" content="http://example.com/img/MySQL-Notes/read-write-separate-overview2.png">
<meta property="article:published_time" content="2025-12-17T09:37:59.000Z">
<meta property="article:modified_time" content="2025-12-17T09:53:03.045Z">
<meta property="article:author" content="mildempeach">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="后端开发">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/img/MySQL-Notes/MySQL-model.png">
  
  
  
  <title>MySQL-Notes - </title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.1"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>mildempeach</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="MySQL-Notes"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        mildempeach
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-12-17 17:37" pubdate>
          December 17, 2025 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          48k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          403 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">MySQL-Notes</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="数据库：MySQL笔记"><a href="#数据库：MySQL笔记" class="headerlink" title="数据库：MySQL笔记"></a>数据库：MySQL笔记</h1><blockquote>
<p>如题。</p>
</blockquote>
<h2 id="1-数据库与MySQL基本概念"><a href="#1-数据库与MySQL基本概念" class="headerlink" title="1. 数据库与MySQL基本概念"></a><strong>1. 数据库与MySQL基本概念</strong></h2><h3 id="1-1-数据库基本概念"><a href="#1-1-数据库基本概念" class="headerlink" title="1.1 数据库基本概念"></a>1.1 数据库基本概念</h3><ul>
<li><strong>数据库（DB，database）</strong>：数据存储的仓库，数据库又可以分为<strong>关系型数据库</strong>和<strong>非关系型数据库</strong>。</li>
<li><strong>关系型数据库</strong>：建立在关系模型基础上，由多张相互连接的二维表组成的数据库。</li>
<li><strong>数据库管理系统（DBMS，database management system）</strong>：操纵和管理数据库的大型软件，包括<code>Oracle</code>、<code>MySQL</code>、<code>IBM db2</code>等等。</li>
<li><strong>SQL（structed query language）</strong>：操作<strong>关系型</strong>数据库的编程语言，是一套统一标准，即对于不同的DBMS，都可以通过同样的SQL去操作。</li>
</ul>
<h3 id="1-2-MySQL介绍与使用"><a href="#1-2-MySQL介绍与使用" class="headerlink" title="1.2 MySQL介绍与使用"></a>1.2 MySQL介绍与使用</h3><p>MySQL是主流的DBMS之一，用于操作关系型数据库，该软件的架构为C-S模式，如图所示。</p>
<p><img src="/img/MySQL-Notes/MySQL-model.png" srcset="/img/loading.gif" lazyload></p>
<p>每一个MySQL服务器中可以建立多个关系型数据库，每个关系型数据库由若干表组成。</p>
<p>下载安装MySQL后，使用MySQL服务前要先启动服务端。安装的时候默认是自动启动的，如果没有选择自动启动或者关闭了服务端，可以在命令行（需管理员模式&#x2F;root）中输入命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Windows</span><br>net start mysql80 <span class="hljs-comment"># 启动服务</span><br>net stop mysql80 <span class="hljs-comment"># 关闭服务 </span><br></code></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu</span><br>systemctl start mysql<br>systemcts restart mysql<br>systemctl stop mysql<br>systemctl status mysql<br></code></pre></td></tr></table></figure>

<p>在服务器正常运行之后，通过客户端与服务端进行连接，可以通过MySQL提供的命令行，输入密码连接；也可以直接使用操作系统（如Windows）的命令行，输入指令连接（需要将mysql写入系统环境变量）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p <br><span class="hljs-comment"># -h xx.xx.xx.xx  指定ip地址</span><br><span class="hljs-comment"># -P xxxx 指定连接端口，MySQL服务端默认监听3306端口 </span><br></code></pre></td></tr></table></figure>

<p>随后输入密码，即可进入。</p>
<h2 id="2-SQL语法与单表操作"><a href="#2-SQL语法与单表操作" class="headerlink" title="2. SQL语法与单表操作"></a><strong>2. SQL语法与单表操作</strong></h2><h3 id="2-1-SQL通用语法"><a href="#2-1-SQL通用语法" class="headerlink" title="2.1 SQL通用语法"></a>2.1 SQL通用语法</h3><ol>
<li>sql可以单行或多行书写，<strong>以分号结尾</strong>；</li>
<li>sql语句可以使用空格&#x2F;缩进来增强语句的可读性；</li>
<li>mysql数据库的sql语句<strong>不区分大小写</strong>，关键字建议使用大写。</li>
<li>注释：</li>
<li>单行注释: -- 注释内容 或 # 注释内容（MySQL特有）</li>
<li>多行注释：&#x2F;* 注释内容 *&#x2F;</li>
</ol>
<table>
<thead>
<tr>
<th>sql语言</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>DDL（Data Definition Language）</td>
<td></td>
</tr>
<tr>
<td>DML（Data Manipulation Language）</td>
<td>数据操作语言，用来对数据库中的数据进行<strong>增删改</strong></td>
</tr>
<tr>
<td>DQL（Data Query Language）</td>
<td>数据查询语言，用来<strong>查询</strong>数据库中表的记录</td>
</tr>
<tr>
<td>DCL（Data Control Language）</td>
<td>数据控制语言，用来创建数据库用户以及访问控制权限</td>
</tr>
</tbody></table>
<h3 id="2-2-DDL"><a href="#2-2-DDL" class="headerlink" title="2.2 DDL"></a>2.2 DDL</h3><p>DDL（Data Definition Language，数据定义语言），用来<strong>定义</strong>数据库对象（数据库、表、字段）。</p>
<h4 id="2-2-1-数据库DDL"><a href="#2-2-1-数据库DDL" class="headerlink" title="2.2.1 数据库DDL"></a>2.2.1 数据库DDL</h4><ul>
<li><strong>查询</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> DATABASES; <span class="hljs-comment">-- 查询所有数据库</span><br><br><span class="hljs-keyword">SELECT</span> DATABASE(); <span class="hljs-comment">-- 查询当前数据库</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>创建</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE [IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>] 数据库名 <br>[<span class="hljs-keyword">DEFAULT</span> CHARSET 字符集] [<span class="hljs-keyword">COLLATE</span> 排序规则]; <span class="hljs-comment">-- 创建数据库</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>删除</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE [IF <span class="hljs-keyword">EXISTS</span>] 数据库名; <span class="hljs-comment">-- 删除某个数据库</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>使用</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE 数据库名; <span class="hljs-comment">-- 使用某个数据库</span><br></code></pre></td></tr></table></figure>
<h4 id="2-2-2-表操作"><a href="#2-2-2-表操作" class="headerlink" title="2.2.2 表操作"></a>2.2.2 表操作</h4><ul>
<li><strong>查询</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> TABLES; <span class="hljs-comment">-- 查询当前数据库所有表</span><br><br><span class="hljs-keyword">DESC</span> 表名; <span class="hljs-comment">-- 查询表结构</span><br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE TABLE</span> 表名; <span class="hljs-comment">-- 查询指定表的建表语句</span><br></code></pre></td></tr></table></figure>
<ul>
<li><strong>创建</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> 表名(<br>    字段 字段类型 [约束] [COMMENT 字段注释],<br>    ....<br>    字段 字段类型 [约束] [COMMENT 字段注释]<br>)[COMMENT 表注释];<br><br><span class="hljs-comment">-- `COMMENT`关键字后的注释是会被写入数据库的，和`--`的注释不同。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>修改</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 添加字段</span><br><span class="hljs-keyword">ALTER TABLE</span> 表名 <br><span class="hljs-keyword">ADD</span> 字段名 数据类型(长度) [约束] [COMMENT 字段注释]; <br><br><span class="hljs-comment">-- 修改数据类型</span><br><span class="hljs-keyword">ALTER TABLE</span> 表名 <br>MODIFY 字段名 新数据类型(长度) [约束] [COMMENT 字段注释]; <br><br><span class="hljs-comment">--修改字段名和字段类型</span><br><span class="hljs-keyword">ALTER TABLE</span> 表名 <br>CHANGE 旧字段名 新字段名 新数据类型(长度) [约束] [COMMENT 字段注释];<br><br><span class="hljs-comment">-- 删除字段</span><br><span class="hljs-keyword">ALTER TABLE</span> 表名 <br><span class="hljs-keyword">DROP</span> 字段名; <br><br><span class="hljs-comment">-- 重命名表</span><br><span class="hljs-keyword">ALTER TABLE</span> 表名 <br>RENAME <span class="hljs-keyword">TO</span> 新表名;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删除</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> <br>[IF <span class="hljs-keyword">EXISTS</span>] 表名; <br><br><span class="hljs-comment">-- 删除指定表，并重新创建该表</span><br><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> 表名; <br><br><span class="hljs-comment">-- 在删除表时，表中的数据也会被删除。</span><br></code></pre></td></tr></table></figure>

<h4 id="2-2-3-MySQL字段类型"><a href="#2-2-3-MySQL字段类型" class="headerlink" title="2.2.3 MySQL字段类型"></a>2.2.3 MySQL字段类型</h4><ul>
<li><strong>数值类型</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>有符号 (SIGNED) 范围</th>
<th>无符号 (UNSIGNED) 范围</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>TINYINT</code></td>
<td>1 byte</td>
<td>(-128, 127)</td>
<td>(0, 255)</td>
<td>小整数值</td>
</tr>
<tr>
<td><code>SMALLINT</code></td>
<td>2 bytes</td>
<td>(-32768, 32767)</td>
<td>(0, 65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td><code>MEDIUMINT</code></td>
<td>3 bytes</td>
<td>(-8388608, 8388607)</td>
<td>(0, 16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td><code>INT</code>（<code>INTEGER</code>）</td>
<td>4 bytes</td>
<td>(-2147483648, 2147483647)</td>
<td>(0, 4294967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td><code>BIGINT</code></td>
<td>8 bytes</td>
<td>(−2^63, 2^63−1)</td>
<td>(0, 2^64−1)</td>
<td>极大整数值</td>
</tr>
<tr>
<td><code>FLOAT</code></td>
<td>4 bytes</td>
<td>(~−3.402823466E+38, ~3.402823466E+38)</td>
<td>0 和 (~1.175494351E−38, ~3.402823466E+38)</td>
<td>单精度浮点数值</td>
</tr>
<tr>
<td><code>DOUBLE</code></td>
<td>8 bytes</td>
<td>(~−1.7976931348623157E+308, ~1.7976931348623157E+308)</td>
<td>0 和 (~2.2250738585072014E−308, ~1.7976931348623157E+308)</td>
<td>双精度浮点数值</td>
</tr>
<tr>
<td><code>DECIMAL</code></td>
<td>依赖于 M(精度) 和 D(标度)</td>
<td>依赖于 M(精度) 和 D(标度)</td>
<td>小数值（精确定点数）</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><strong>字符串类型</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>CHAR</code></td>
<td>0–255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td><code>VARCHAR</code></td>
<td>0–65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td><code>TINYBLOB</code></td>
<td>0–255 bytes</td>
<td>不超过 255 个字节的二进制数据</td>
</tr>
<tr>
<td><code>TINYTEXT</code></td>
<td>0–255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td><code>BLOB</code></td>
<td>0–65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td><code>TEXT</code></td>
<td>0–65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td><code>MEDIUMBLOB</code></td>
<td>0–16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td><code>MEDIUMTEXT</code></td>
<td>0–16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td><code>LONGBLOB</code></td>
<td>0–4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td><code>LONGTEXT</code></td>
<td>0–4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li><code>MySQL</code>可以存储二进制数据，但由于性能不高，在开发中常常不这么做，而是将二进制数据存放在专有的文件服务器上。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><strong><code>CHAR</code>和<code>VARCHAR</code>对比</strong>：<code>CHAR</code>和<code>VARCHAR</code>需要通过<code>()</code>指定存储的字符串的字符长度；<code>CHAR</code>类型存放数据，即使数据的长度小于声明长度，也会补全，因此为定长，而<code>VARCHAR</code>不会进行补全；<code>CHAR</code>类型数据插入性能高，<code>VARCHAR</code>类型数据插入性能低。</li>
</ol>
</blockquote>
<ul>
<li><strong>日期类型</strong></li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>大小</th>
<th>范围</th>
<th>格式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>DATE</code></td>
<td>3</td>
<td>1000-01-01 至 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td><code>TIME</code></td>
<td>3</td>
<td>-838:59:59 至 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td><code>YEAR</code></td>
<td>1</td>
<td>1901 至 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td><code>DATETIME</code></td>
<td>8</td>
<td>1000-01-01 00:00:00 至 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td><code>TIMESTAMP</code></td>
<td>4</td>
<td>1970-01-01 00:00:01 至 2038-01-19 03:14:07</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时区相关</td>
</tr>
</tbody></table>
<h3 id="2-3-DML"><a href="#2-3-DML" class="headerlink" title="2.3 DML"></a>2.3 DML</h3><p>DML（Data Manipulation Language），数据操作语言，用来对数据库表中的数据进行<strong>增删改</strong>操作。</p>
<ul>
<li><strong>增</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 指定字段添加数据 </span><br><span class="hljs-keyword">INSERT INTO</span> 表名(字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>,...) <br><span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...); <br><br><span class="hljs-comment">-- 给全部字段添加数据，值的排列顺序与表中定义字段的顺序一致</span><br><span class="hljs-keyword">INSERT INTO</span> 表名 <br><span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...); <br><br><span class="hljs-comment">-- 批量添加数据</span><br><span class="hljs-keyword">INSERT INTO</span> 表名(字段名<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span>,...) <br><span class="hljs-keyword">VALUES</span>(值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...),<br>      (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...),<br>      (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...)...;<br><br><span class="hljs-keyword">INSERT INTO</span> 表名<br><span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...),<br>       (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...),<br>       (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,...)...;<br><br><span class="hljs-comment">-- 1. 插入的字段顺序与值的顺序一一对应。</span><br><span class="hljs-comment">-- 2. 字符串和日期型数据的值应该包含在引号`&#x27;&#x27;`内。</span><br><span class="hljs-comment">-- 3. 插入的数据大小，应该在字段的规定范围内。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>改</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> 表名<br><span class="hljs-keyword">SET</span> 字段名<span class="hljs-number">1</span> <span class="hljs-operator">=</span> 值<span class="hljs-number">1</span>, 字段名<span class="hljs-number">2</span><span class="hljs-operator">=</span>值<span class="hljs-number">2</span>,...<br>[<span class="hljs-keyword">WHERE</span> 条件];<br><br><span class="hljs-comment">-- `WHERE`语句为而可选项，如果没有条件，则会修改整张表所有的数据。</span><br><span class="hljs-comment">-- `WHERE`语句的条件可选项可以见DQL的条件查询。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名<br>[<span class="hljs-keyword">WHERE</span> 条件];<br><br><span class="hljs-comment">-- `WHERE`语句为可选项，如果没有条件，则会删除整张表中的数据。</span><br><span class="hljs-comment">-- `WHERE`语句的条件可选项可以见DQL的条件查询。</span><br><span class="hljs-comment">-- `DELETE`语句删除的是一条或多条**完整的记录**，不能删除某条记录的字段，后者可以使用`UPDATE`语句将字段值赋值为空。</span><br></code></pre></td></tr></table></figure>

<h3 id="2-4-DQL"><a href="#2-4-DQL" class="headerlink" title="2.4 DQL"></a>2.4 DQL</h3><p>DQL（Data Query Language，数据查询语言），用来<strong>查询</strong>数据库中表的记录，基本格式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名列表<br><span class="hljs-keyword">WHERE</span> 条件列表<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段列表<br><span class="hljs-keyword">HAVING</span> 分组后条件列表<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 排序字段列表<br>LIMIT 分页参数;<br></code></pre></td></tr></table></figure>
<h4 id="2-4-1-基本查询"><a href="#2-4-1-基本查询" class="headerlink" title="2.4.1 基本查询"></a>2.4.1 基本查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询全部字段</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span>, ... <span class="hljs-keyword">FROM</span> 表名;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 表名;<br><br><span class="hljs-comment">-- 设置字段别名</span><br><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span> <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> <span class="hljs-keyword">AS</span> 别名<span class="hljs-number">2</span>, ... <span class="hljs-keyword">FROM</span> 表名;<br><br><span class="hljs-comment">-- 去重查询 DISTINCT</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名;<br><br></code></pre></td></tr></table></figure>

<h4 id="2-4-2-条件查询"><a href="#2-4-2-条件查询" class="headerlink" title="2.4.2 条件查询"></a>2.4.2 条件查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件列表;<br></code></pre></td></tr></table></figure>

<p><code>WHERE</code>语句中的条件表达式可使用比较运算符和逻辑运算符进行构建，具体可用符号如下：</p>
<ul>
<li><strong>比较运算符</strong></li>
</ul>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>&gt;</code></td>
<td>大于</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
</tr>
<tr>
<td><code>=</code></td>
<td>等于</td>
</tr>
<tr>
<td><code>&lt;&gt;</code> 或 <code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>BETWEEN 最小值 AND 最大值</code></td>
<td>在某个范围之内（包含最小、最大值）</td>
</tr>
<tr>
<td><code>IN(...)</code></td>
<td>在IN后的列表中的值</td>
</tr>
<tr>
<td><code>LIKE ...</code></td>
<td>模糊匹配 <code>_</code>匹配单个字符，<code>%</code>匹配任意个字符（占位符）</td>
</tr>
<tr>
<td><code>IS NULL</code></td>
<td>判断为空</td>
</tr>
</tbody></table>
<ul>
<li><strong>逻辑运算符</strong></li>
</ul>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>AND</code> 或 <code>&amp;&amp;</code></td>
<td>并（多个条件同时成立）</td>
</tr>
<tr>
<td><code>OR</code> 或 <code>||</code></td>
<td>或（多个条件任意一个成立）</td>
</tr>
<tr>
<td><code>NOT</code> 或 <code>!</code></td>
<td>取反（不是）</td>
</tr>
</tbody></table>
<h4 id="2-4-3-聚合函数和分组查询"><a href="#2-4-3-聚合函数和分组查询" class="headerlink" title="2.4.3 聚合函数和分组查询"></a>2.4.3 聚合函数和分组查询</h4><ul>
<li><strong>聚合函数</strong></li>
</ul>
<p><strong>聚合函数</strong>作用于某一列数据，进行纵向计算，常见聚合函数如下：</p>
<table>
<thead>
<tr>
<th>聚合函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>count </code></td>
<td>统计数量</td>
</tr>
<tr>
<td><code>max</code></td>
<td>最大值</td>
</tr>
<tr>
<td><code>min</code></td>
<td>最小值</td>
</tr>
<tr>
<td><code>avg</code></td>
<td>平均值</td>
</tr>
<tr>
<td><code>sum</code></td>
<td>求和</td>
</tr>
</tbody></table>
<p>使用聚合函数时，指定聚合函数作用的列（即字段名）即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 聚合函数(字段列表) <span class="hljs-keyword">FROM</span> 表名;<br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>NULL值不参与聚合函数运算。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><code>AVG</code>后也可以加上逻辑表达式，计算的就是逻辑表达式为真的占比，常用来替代<code>SUM(IF...) / COUNT(*)</code>的逻辑，在sql语句中很常用。</li>
</ol>
</blockquote>
<ul>
<li><strong>分组查询</strong></li>
</ul>
<p><strong>分组查询</strong>常常需要用到聚合函数，其基本语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br>[<span class="hljs-keyword">WHERE</span> 条件]<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 分组字段名<br>[<span class="hljs-keyword">HAVING</span> 分组后过滤的条件]  <br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>WHERE</code>在分组之前进行过滤，不满足条件，不参与分组（实际作用对象是每一条记录）；<code>HAVING</code>是分组后对结果进行过滤（实际作用结果是对每一个组）。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>在<code>WHERE</code>语句中不能使用聚合函数，在<code>HAVING</code>语句中可以使用聚合函数。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>执行顺序：<code>WHERE</code> -&gt; <code>SELECT</code>后的聚合函数 -&gt; <code>HAVING</code>。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>使用分组查询，<code>SELECT</code>后的字段一般为聚合函数及分组字段，查询其他字段无意义。</li>
</ol>
</blockquote>
<h4 id="2-4-4-排序查询"><a href="#2-4-4-排序查询" class="headerlink" title="2.4.4 排序查询"></a>2.4.4 排序查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> 排序方式<span class="hljs-number">1</span>, 字段<span class="hljs-number">2</span> 排序方式<span class="hljs-number">2</span>, ... ;<br></code></pre></td></tr></table></figure>

<p><strong>排序方式</strong>有两种可选：</p>
<ol>
<li><code>ASC</code>：升序（默认值）</li>
<li><code>DESC</code>：降序</li>
</ol>
<p><strong>多字段排序</strong>指的是先按照第一个字段以及排序方式进行排序，如果第一个字段相同，则按照第二个字段以及排序方式进行排序，以此类推。</p>
<h4 id="2-4-5-分页查询"><a href="#2-4-5-分页查询" class="headerlink" title="2.4.5 分页查询"></a>2.4.5 分页查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表名<br>LIMIT 起始索引, 查询记录数;<br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>起始索引从0开始，起始索引&#x3D;（查询页码 - 1）* 每页显示记录数。（查询页码是从1开始）</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>如果查询的是第一页数据，起始索引可以省略，直接简写为<code>LIMIT 查询记录数</code>。</li>
</ol>
</blockquote>
<h4 id="2-4-6-DQL语句执行顺序"><a href="#2-4-6-DQL语句执行顺序" class="headerlink" title="2.4.6 DQL语句执行顺序"></a>2.4.6 DQL语句执行顺序</h4><ol>
<li><code>FROM</code>语句定位对应的表。</li>
<li><code>WHERE</code>语句对记录进行筛选。</li>
<li><code>GROUP BY</code>根据字段对记录进行分组。</li>
<li><code>HAVING</code>对组进行筛选。</li>
<li><code>SELECT</code>从筛选的结果中选出相应的字段名以及对应的字段值&#x2F;聚合函数作用后的字段值。</li>
<li><code>ORDER BY</code>对于选出的最终结果进行排序。</li>
<li><code>LIMIT</code>对于最终结果进行分页展示。</li>
</ol>
<blockquote>
<ol>
<li>这里会涉及到使用别名的作用域问题。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>只要别名是在同一个查询块的 SELECT 子句里定义的，<strong>MySQL</strong>就允许在同级的 ORDER BY、GROUP BY、HAVING 中直接引用它——解析器会先解析<code>SELECT</code>列表，把别名和它的表达式对应起来，然后在构造执行计划时替换回去。（<strong>MySQL特有</strong>）</li>
</ol>
</blockquote>
<h3 id="2-5-DCL"><a href="#2-5-DCL" class="headerlink" title="2.5 DCL"></a>2.5 DCL</h3><p>DCL（Data Control Language，数据控制语言），用来<strong>管理数据库用户、控制数据库的访问权限</strong>。</p>
<h4 id="2-5-1-管理用户"><a href="#2-5-1-管理用户" class="headerlink" title="2.5.1 管理用户"></a>2.5.1 管理用户</h4><ul>
<li><strong>查询用户</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE mysql;<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>创建用户</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span> <br>IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;密码&#x27;</span>;<br><br><span class="hljs-comment">-- 如果希望用户在任何主机都可以访问数据库，可以将`&#x27;主机名&#x27;`替换为`&#x27;%&#x27;`。</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>修改用户密码</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span><br>IDENTIFIED <span class="hljs-keyword">with</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;新密码&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删除</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="2-5-2-管理权限"><a href="#2-5-2-管理权限" class="headerlink" title="2.5.2 管理权限"></a>2.5.2 管理权限</h4><ul>
<li><strong>权限分类</strong></li>
</ul>
<p><code>MySQL</code>中定义了很多种权限，但是常用的权限只有以下几种：</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code>, <code>ALL PRIVILEGES</code></td>
<td>所有权限</td>
</tr>
<tr>
<td><code>SELECT</code></td>
<td>查询数据</td>
</tr>
<tr>
<td><code>INSERT</code></td>
<td>插入数据</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>修改数据</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>删除数据</td>
</tr>
<tr>
<td><code>ALTER</code></td>
<td>修改表</td>
</tr>
<tr>
<td><code>DROP</code></td>
<td>删除数据库&#x2F;表&#x2F;视图</td>
</tr>
<tr>
<td><code>CREATE</code></td>
<td>创建数据库&#x2F;表</td>
</tr>
</tbody></table>
<ul>
<li><strong>查询权限</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> GRANTS<br><span class="hljs-keyword">FOR</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>授予权限</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">GRANT</span> 权限列表<br><span class="hljs-keyword">ON</span> 数据库.表名<br><span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>撤销权限</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">REVOKE</span> 权限列表<br><span class="hljs-keyword">ON</span> 数据库.表名<br><span class="hljs-keyword">FROM</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;主机名&#x27;</span>;<br><br><span class="hljs-comment">-- 这里的数据库和表名，如果需要是全部，可以用`*`来代替。</span><br></code></pre></td></tr></table></figure>

<h3 id="2-6-内置函数"><a href="#2-6-内置函数" class="headerlink" title="2.6 内置函数"></a>2.6 内置函数</h3><p>函数是指一段可以直接被另一段程序调用的程序或代码，在<code>MySQL</code>中内置了许多不同的函数。</p>
<h4 id="2-6-1-字符串函数"><a href="#2-6-1-字符串函数" class="headerlink" title="2.6.1 字符串函数"></a>2.6.1 字符串函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>CONCAT(S1, S2, ... SN)</code></td>
<td>将S1、S2...SN拼接成一个字符串</td>
</tr>
<tr>
<td><code>LOWER(str)</code></td>
<td>将字符串str全部转为小写</td>
</tr>
<tr>
<td><code>UPPER(str)</code></td>
<td>将字符串str全部转为大写</td>
</tr>
<tr>
<td><code>LPAD(str, n, pad)</code></td>
<td>在字符串左侧使用pad进行填充，直到字符串总长度达到n；如果本身str已经超过了n，则对str进行截取，取左侧n个字符</td>
</tr>
<tr>
<td><code>RPAD(str, n, pad)</code></td>
<td>在字符串右侧使用pad进行填充，直到字符串总长度达到n；如果本身str已经超过了n，则对str进行截取，取右侧n个字符</td>
</tr>
<tr>
<td><code>TRIM(str)</code></td>
<td>去掉字符串头部和尾部的空格</td>
</tr>
<tr>
<td><code>SUBSTRING(str, start, len)</code></td>
<td>返回字符串str从start位置起的len个长度的字符串（索引从1开始）， 当省略第三个字段的时候，默认到字符串末尾</td>
</tr>
<tr>
<td><code>CHAR_LENGTH(str)</code></td>
<td>计算字符长度，无论中文字符、英文字符、数字都算1个长度</td>
</tr>
<tr>
<td><code>LENGTH(str)</code></td>
<td>计算字节长度（与编码有关），英文字符、数字仍然为一个字节，汉字在utf8中三个字节，在gbk中两个字节</td>
</tr>
</tbody></table>
<h4 id="2-6-2-数值函数"><a href="#2-6-2-数值函数" class="headerlink" title="2.6.2 数值函数"></a>2.6.2 数值函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>CEIL(x)</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>FLOOR(x)</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>MOD(x, y)</code></td>
<td>返回 x mod y的结果</td>
</tr>
<tr>
<td><code>RAND()</code></td>
<td>返回0~1内的随机数</td>
</tr>
<tr>
<td><code>ROUND(x, y)</code></td>
<td>求参数x的四舍五入值，保留y位小数</td>
</tr>
</tbody></table>
<h4 id="2-6-3-日期函数"><a href="#2-6-3-日期函数" class="headerlink" title="2.6.3 日期函数"></a>2.6.3 日期函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>CURDATE()</code></td>
<td>返回当前日期</td>
</tr>
<tr>
<td><code>CURTIME()</code></td>
<td>返回当前时间</td>
</tr>
<tr>
<td><code>NOW()</code></td>
<td>返回当前日期和时间</td>
</tr>
<tr>
<td><code>YEAR(date)</code></td>
<td>获取指定date的年份</td>
</tr>
<tr>
<td><code>MONTH(date)</code></td>
<td>获取指定date的月份</td>
</tr>
<tr>
<td><code>DAY(date)</code></td>
<td>获取指定date的日</td>
</tr>
<tr>
<td><code>DATE_ADD(date, INTERVAL expr type)</code></td>
<td>返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td>
</tr>
<tr>
<td><code>DATEDIFF(date1, date2)</code></td>
<td>返回起始时间date1和结束时间date2之间的天数。（date1 - date2）</td>
</tr>
<tr>
<td><code>DATE_FORMAT(date, format)</code></td>
<td>用于以不同的格式显示日期&#x2F;时间数据。date 参数是合法的日期，format 规定日期&#x2F;时间的输出格式，如%Y表示年份，%M表示月份</td>
</tr>
</tbody></table>
<h4 id="2-6-4-流程函数"><a href="#2-6-4-流程函数" class="headerlink" title="2.6.4 流程函数"></a>2.6.4 流程函数</h4><table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>IF(value, t, f)</code></td>
<td>如果value为true，返回t，否则返回f</td>
</tr>
<tr>
<td><code>IFNULL(value1, value2)</code></td>
<td>如果value1不为空，返回value1，否则返回value2</td>
</tr>
<tr>
<td><code>CASE WHEN val1 THEN res1 ... ELSE default END</code></td>
<td>如果val1为true，返回res1，否则返回default默认值</td>
</tr>
<tr>
<td><code>CASE expr WHEN val1 THEN res1 ... ELSE default END</code></td>
<td>如果expr的值等于val1，返回res1，否则返回default默认值</td>
</tr>
</tbody></table>
<h3 id="2-7-约束"><a href="#2-7-约束" class="headerlink" title="2.7 约束"></a>2.7 约束</h3><p>约束是作用于表中字段上的限制，用于限制存储在表中的数据，常用于<a href="#222-%E8%A1%A8%E6%93%8D%E4%BD%9C">DDL语句中有关表的操作</a>，如创建表、修改表中字段结构；使用约束用来保证数据库中数据的正确、有效性和完整性。</p>
<h4 id="2-7-1-约束的分类"><a href="#2-7-1-约束的分类" class="headerlink" title="2.7.1 约束的分类"></a>2.7.1 约束的分类</h4><table>
<thead>
<tr>
<th>约束</th>
<th>描述</th>
<th>关键字</th>
</tr>
</thead>
<tbody><tr>
<td>非空约束</td>
<td>限制字段的数据不能为null</td>
<td><code>NOT NULL</code></td>
</tr>
<tr>
<td>唯一约束</td>
<td>保证该字段的所有数据都是唯一的，即不能重复</td>
<td><code>UNIQUE</code></td>
</tr>
<tr>
<td>主键约束</td>
<td>主键是一行数据的唯一标识，要求非空且唯一</td>
<td><code>PRIMARY KEY</code></td>
</tr>
<tr>
<td>默认约束</td>
<td>保存数据时，如果未指定该字段的值，则采用默认值</td>
<td><code>DEFAULT</code></td>
</tr>
<tr>
<td>检查约束（8.0.16版本后）</td>
<td>保证字段值满足某个条件</td>
<td><code>CHECK</code></td>
</tr>
<tr>
<td>外键约束</td>
<td>用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td>
<td><code>FOREIGN KEY</code></td>
</tr>
<tr>
<td>自动增长</td>
<td>用来让插入数据的该字段值自动增长</td>
<td><code>AUTO_INCREMENT</code></td>
</tr>
</tbody></table>
<blockquote>
<ol>
<li>同一个字段可以有多个约束条件，多个约束之间只需要空格隔开即可。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>可以指定多个字段为主键，以<code>primary key (字段列表)</code>的形式。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>可以用<code>CONSTRAINT</code>关键字给约束命名，语法为<code>CONSTRAINT 约束名 约束类型</code>。</li>
</ol>
</blockquote>
<ul>
<li><strong>约束使用案例</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 约束创建表格demo</span><br><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (<br>    id <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span> AUTO_INCREMENT COMMENT <span class="hljs-string">&#x27;主键&#x27;</span>,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">NOT NULL</span> <span class="hljs-keyword">UNIQUE</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>    age <span class="hljs-type">INT</span> <span class="hljs-keyword">CHECK</span> ( age <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span> <span class="hljs-keyword">AND</span> age <span class="hljs-operator">&lt;=</span> <span class="hljs-number">120</span> ) COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>    status <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;1&#x27;</span> COMMENT <span class="hljs-string">&#x27;状态&#x27;</span>,<br>    gender <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) COMMENT <span class="hljs-string">&#x27;性别&#x27;</span><br>) COMMENT <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="2-7-2-外键约束详解"><a href="#2-7-2-外键约束详解" class="headerlink" title="2.7.2 外键约束详解"></a>2.7.2 外键约束详解</h4><p>外键所在的当前表为子表&#x2F;从表，外键所指向的外部表为父表&#x2F;主表。</p>
<ul>
<li><strong>添加外键</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建表的时候添加外键</span><br><span class="hljs-keyword">CREATE TABLE</span> 表名(<br>    字段名 数据类型,<br>    ...<br>    [<span class="hljs-keyword">CONSTRAINT</span> 外键名称] <span class="hljs-keyword">FOREIGN KEY</span> (外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名)<br>);<br><br><span class="hljs-comment">-- 修改表的时候添加外键</span><br><span class="hljs-keyword">ALTER TABLE</span> 表名<br><span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">CONSTRAINT</span> 外键名称] <span class="hljs-keyword">FOREIGN KEY</span> (外键字段名) <span class="hljs-keyword">REFERENCES</span> 主表(主表列名); <br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删除外键</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">FOREIGN KEY</span> 外键名称;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>外键关系更新&#x2F;删除行为</strong></li>
</ul>
<table>
<thead>
<tr>
<th>行为名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>NO ACTION</code></td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。</td>
</tr>
<tr>
<td><code>RESTRICT</code></td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新。</td>
</tr>
<tr>
<td><code>CASCADE</code></td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录。</td>
</tr>
<tr>
<td><code>SET NULL</code></td>
<td>当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null。（这就要求该外键允许取null）</td>
</tr>
<tr>
<td><code>SET DEFAULT</code></td>
<td>父表有变更时，子表将外键列设置为一个默认的值（Innodb不支持）</td>
</tr>
</tbody></table>
<blockquote>
<p>默认的行为模式为<code>NO ACTION</code>和<code>RESTRICT</code>，这两者的行为是一致的。</p>
</blockquote>
<p>设置行为模式的语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER TABLE</span> 表名<br><span class="hljs-keyword">ADD</span> [<span class="hljs-keyword">CONSTRAINT</span> 外键名称] <span class="hljs-keyword">FOREIGN KEY</span> (外键字段) <span class="hljs-keyword">REFERENCES</span> 主表名(主表字段名)<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">UPDATE</span> [行为名]<br><span class="hljs-keyword">ON</span> <span class="hljs-keyword">DELETE</span> [行为名];<br></code></pre></td></tr></table></figure>

<h2 id="3-多表与高级查询"><a href="#3-多表与高级查询" class="headerlink" title="3. 多表与高级查询"></a><strong>3. 多表与高级查询</strong></h2><h3 id="3-1-多表关系与多表查询"><a href="#3-1-多表关系与多表查询" class="headerlink" title="3.1 多表关系与多表查询"></a>3.1 多表关系与多表查询</h3><ul>
<li><strong>多表关系</strong></li>
</ul>
<ol>
<li><strong>一对多（多对一）</strong></li>
</ol>
<p>案例：部门与员工的关系，一个部门对应多个员工，一个员工对应一个部门</p>
<p>实现：在多的一方建立外键，指向一的一方的主键。</p>
<p>如案例中，员工为多的一方，则员工表中建立一个外键，对应部门ID（部门表中的主键）。</p>
<ol start="2">
<li><strong>多对多</strong></li>
</ol>
<p>案例：学生与课程的关系，一个学生可以选修多门课程，一门课程也可以供多个学生选择。</p>
<p>实现：抽出两张表的主键，作为第三张表的两个外键。</p>
<ol start="3">
<li><strong>一对一</strong></li>
</ol>
<p>案例：用户与用户详情的关系</p>
<blockquote>
<p>常用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，提升操作效率。</p>
</blockquote>
<p>实现：选取任意一张表建立外键，指向另一张表的主键，并且要求该外键的约束条件为<code>UNIQUE</code>。</p>
<ul>
<li><strong>多表查询</strong></li>
</ul>
<p>多表查询就是在一条<code>DQL</code>语句中，从多张表中查询数据；多表查询时，表中的记录会进行笛卡尔积，查询的过程中最重要的就是消除无效的笛卡尔积。</p>
<p>多表查询可进行如下分类：</p>
<p><img src="/img%5CMySQL-Notes%5Cmulti-table-classify.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="3-2-连接查询"><a href="#3-2-连接查询" class="headerlink" title="3.2 连接查询"></a>3.2 连接查询</h3><h4 id="3-2-1-内连接"><a href="#3-2-1-内连接" class="headerlink" title="3.2.1 内连接"></a>3.2.1 内连接</h4><p>内连接查询的是两张表交集的部分；内连接可以没有连接条件（即<code>WHERE</code>&#x2F;<code>ON</code>语句），这种情况下，默认为笛卡尔积。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 隐式内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span><br><span class="hljs-keyword">WHERE</span> 连接条件; <br><br><span class="hljs-comment">-- 显式内连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span><br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-2-外连接"><a href="#3-2-2-外连接" class="headerlink" title="3.2.2 外连接"></a>3.2.2 外连接</h4><p>外连接包含左外连接和右外连接，他们分别包含左表和右表的全部数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 左外连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">LEFT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span><br><span class="hljs-keyword">ON</span> 连接条件;<br><br><span class="hljs-comment">-- 右外连接</span><br><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> <span class="hljs-keyword">RIGHT</span> [<span class="hljs-keyword">OUTER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span><br><span class="hljs-keyword">ON</span> 连接条件;<br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>左外连接用得比较多，理论上可以不需要右外连接。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>左外连接保证只要左表有数据，最终的输出的记录数一定和左表的记录数相同，也就是说，哪怕右表不存在任何记录，左表中有记录，也会产生连接的结果，此时右表的字段均为<code>NULL</code>。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>外连接不能省略<code>ON</code>，否则会报错。</li>
</ol>
</blockquote>
<h4 id="3-2-3-自连接"><a href="#3-2-3-自连接" class="headerlink" title="3.2.3 自连接"></a>3.2.3 自连接</h4><p>相当于将一张表看成是两张表来做多表连接查询，使用的时候对表起别名即可，可以使用内连接&#x2F;外连接。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> [<span class="hljs-keyword">AS</span>] 别名<span class="hljs-number">2</span><br><span class="hljs-keyword">ON</span> 连接条件;<br><br><span class="hljs-comment">-- 以上使用了隐式内连接，除此之外显式内连接、外连接都可以使用。</span><br></code></pre></td></tr></table></figure>

<h3 id="3-3-联合查询"><a href="#3-3-联合查询" class="headerlink" title="3.3 联合查询"></a>3.3 联合查询</h3><p>联合查询可以将多次查询的结果合并起来，形成一个新的查询结果集。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span><br>....<br><span class="hljs-keyword">UNION</span> [<span class="hljs-keyword">ALL</span>]<br><span class="hljs-keyword">SELECT</span> 字段列表<br><span class="hljs-keyword">FROM</span> 表<span class="hljs-number">2</span><br>....;<br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>多次查询可以做联合查询的前提条件是返回的字段列表的数目和类型必须一一对应，保持一致。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><code>UNION ALL</code>会将两个查询的结果直接合并到一起，<code>UNION</code>会对合并之后的数据进行<strong>去重</strong>。</li>
</ol>
</blockquote>
<h3 id="3-4-子查询"><a href="#3-4-子查询" class="headerlink" title="3.4 子查询"></a>3.4 子查询</h3><p>SQL语句（<code>INSERT</code>&#x2F;<code>DELETE</code>&#x2F;<code>UPDATE</code>&#x2F;<code>SELECT</code>）中嵌套的<code>SELECT</code>语句，称为子查询&#x2F;嵌套查询，如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 子查询示例</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> t1<br><span class="hljs-keyword">WHERE</span> column1 <span class="hljs-operator">=</span> (<span class="hljs-keyword">SELECT</span> column1<br>                <span class="hljs-keyword">FROM</span> t2<br>                );<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>根据子查询的结果分类</strong></li>
</ul>
<ol>
<li>标量子查询：子查询结果为单个值。</li>
<li>列子查询：子查询结果为一列。</li>
<li>行子查询：子查询结果为一行。</li>
<li>表子查询：子查询结果为多行多列。</li>
</ol>
<ul>
<li><strong>根据子查询位置分类</strong></li>
</ul>
<ol>
<li><code>WHERE</code>之后。</li>
<li><code>FROM</code>之后。</li>
<li><code>SELECT</code>之后。</li>
</ol>
<h4 id="3-4-1-标量子查询"><a href="#3-4-1-标量子查询" class="headerlink" title="3.4.1 标量子查询"></a>3.4.1 标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等），如查询某个表的单个字段，且根据筛选条件，只返回了一条记录。</p>
<p>常用的操作符： <code>=</code> <code>&lt;&gt;</code> <code>&gt;</code> <code>&gt;=</code> <code>&lt;</code> <code>&lt;=</code> <code>IS NULL</code> <code>IS NOT NULL</code></p>
<p>通过这些操作符，在外层查询的<code>WHERE</code>语句中，可以让某个字段与标量子查询的结果进行比较，完成筛选。</p>
<h4 id="3-4-2-列子查询"><a href="#3-4-2-列子查询" class="headerlink" title="3.4.2 列子查询"></a>3.4.2 列子查询</h4><p>子查询返回的结果是一列（可以是多行），如查询某个表的单个字段，且根据筛选条件，返回了多个记录（可以看成是多个标量组成的一个集合）。</p>
<p>常用的操作符：</p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>IN</code></td>
<td>在指定的集合范围之内</td>
</tr>
<tr>
<td><code>NOT IN</code></td>
<td>不在指定的集合范围之内</td>
</tr>
<tr>
<td><code>ANY/SOME</code></td>
<td>子查询返回列表中，有任意一个元素满足指定条件即可</td>
</tr>
<tr>
<td><code>ALL</code></td>
<td>子查询返回列表中的所有元素都必须满足指定条件</td>
</tr>
</tbody></table>
<blockquote>
<p>ALL&#x2F;ANY&#x2F;SOME的用法，都只能与比较运算符相结合，且比较运算符必须位于前方，如 <code>&gt; SOME (子查询)</code>。</p>
</blockquote>
<h4 id="3-4-3-行子查询"><a href="#3-4-3-行子查询" class="headerlink" title="3.4.3 行子查询"></a>3.4.3 行子查询</h4><p>子查询返回的结果是一行（可以是多列），如查询某个表的多个字段，且根据筛选条件，返回了一条记录（可以看成是按<code>SELECT</code>后的字段顺序对应的值按序组成的行向量）。</p>
<p>常用的操作符：<code>=</code> <code>&lt;&gt;</code></p>
<h4 id="3-4-4-表子查询"><a href="#3-4-4-表子查询" class="headerlink" title="3.4.4 表子查询"></a>3.4.4 表子查询</h4><p>子查询返回的结果是多行多列，如查询某个表的多个字段，且根据筛选条件，返回了多条记录（可以看成是多个行向量组成的集合）。</p>
<p>常用的操作符：<code>IN</code> <code>NOT IN</code> <code>EXISTS</code> <code>NOT EXISTS</code></p>
<h2 id="4-数据库对象与编程"><a href="#4-数据库对象与编程" class="headerlink" title="4. 数据库对象与编程"></a><strong>4. 数据库对象与编程</strong></h2><h3 id="4-1-视图"><a href="#4-1-视图" class="headerlink" title="4.1 视图"></a>4.1 视图</h3><p>视图（View）是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时<strong>动态生成</strong>的；在MySQL中允许基于一张视图继续创建视图。</p>
<p>视图的作用在于：</p>
<ol>
<li>简化用户对数据的理解和一些操作：可以将经常使用的查询定义为视图，往后只需要查询视图就可以，简化<code>SELECT</code>语句的编写。</li>
<li>安全：通过视图和检查选项功能保证用户只能查询和修改满足约束条件的数据。</li>
<li>数据独立：视图帮助用户屏蔽真实表结构变化带来的影响。</li>
</ol>
<h4 id="4-1-1-视图SQL语法"><a href="#4-1-1-视图SQL语法" class="headerlink" title="4.1.1 视图SQL语法"></a>4.1.1 视图SQL语法</h4><ul>
<li><strong>创建视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">VIEW</span> 视图名称[(列名列表)] <br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> 语句<br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>查询视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">VIEW</span> 视图名称; <span class="hljs-comment">-- 查看创建视图的语句</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> 视图名称; <span class="hljs-comment">-- 查看视图数据</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>修改视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 方法一（和创建一样）</span><br><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">OR</span> REPLACE] <span class="hljs-keyword">VIEW</span> 视图名称[(列名列表)] <br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> 语句<br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION];<br><br><span class="hljs-comment">-- 方法二</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">VIEW</span> 视图名称[(列名列表)] <br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> 语句<br>[<span class="hljs-keyword">WITH</span> [<span class="hljs-keyword">CASCADED</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">LOCAL</span>] <span class="hljs-keyword">CHECK</span> OPTION];<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删除视图</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">VIEW</span> [IF <span class="hljs-keyword">EXISTS</span>] 视图名称 [,视图名称] ... ;<br></code></pre></td></tr></table></figure>

<h4 id="4-1-2-视图的更新"><a href="#4-1-2-视图的更新" class="headerlink" title="4.1.2 视图的更新"></a>4.1.2 视图的更新</h4><p>视图的可更新指的是能够对视图进行插入&#x2F;更新&#x2F;删除记录的操作，并能够影响到实际表中的数据。要使视图可更新，<strong>视图中的行与基础表中的行必须存在一对一的关系</strong>，如果视图的<code>SELECT</code>中包含以下关键词，则该视图不可更新。</p>
<ul>
<li>聚合函数、窗口函数</li>
<li><code>DISTINCT</code></li>
<li><code>GROUP BY</code></li>
<li><code>HAVING</code></li>
<li><code>UNION</code>、<code>UNION ALL</code></li>
<li><code>JOIN</code></li>
</ul>
<blockquote>
<p><code>JOIN</code>的情况比较特殊，假设视图中的<code>SELECT</code>语句中对表a和表b做了连接操作，但选取的字段全部来自其中一张表，只在这种情况下视图是可更新的，且在插入时需要指定字段名。</p>
</blockquote>
<h4 id="4-1-3-检查选项"><a href="#4-1-3-检查选项" class="headerlink" title="4.1.3 检查选项"></a>4.1.3 检查选项</h4><p>在可更新的视图上，如果视图在创建时在<code>SELECT</code>语句的<code>WHERE</code>子句中指定了视图的条件，可以通过<strong>检查选项</strong>保证在对视图进行更新（插入&#x2F;修改&#x2F;删除记录）的时候只能对同样符合条件的记录进行操作，否则不能操作。</p>
<p>具体判断流程如下，在更新视图时，检查更新的记录与创建视图时的约束条件：</p>
<ol>
<li>对于无检查选项的视图：无需满足约束条件，如果存在父视图，则递归检查父视图；</li>
<li>对于使用了默认（<code>CASCADED</code>）检查选项的视图：则需要满足当前的约束条件，同时级联向上，不管其父视图是否使用检查选项、检查选项使用的是<code>CASCADED</code>还是<code>LOCAL</code>，都需要满足其约束条件，直到最顶层；</li>
<li>对于使用了本地（<code>LOCAL</code>）检查选项的视图：需要满足当前的约束条件，如果存在父视图，则递归检查其父视图。</li>
</ol>
<blockquote>
<p>事实上<code>LOCAL</code>和<code>CASCADED</code>的级别就在于，<code>CASCADED</code>要求向上递归的所有条件都必须满足，而<code>LOCAL</code>只要求满足当前视图的约束条件。</p>
</blockquote>
<h3 id="4-2-存储过程"><a href="#4-2-存储过程" class="headerlink" title="4.2 存储过程"></a>4.2 存储过程</h3><p>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，实际上是数据库SQL语言层面的代码封装与复用，其表现形式类似于函数，能够接收参数、具有返回值。</p>
<p>存储过程能够减少网络交互，提升数据库操作的效率。</p>
<h4 id="4-2-1-存储过程SQL语法"><a href="#4-2-1-存储过程SQL语法" class="headerlink" title="4.2.1 存储过程SQL语法"></a>4.2.1 存储过程SQL语法</h4><ul>
<li><strong>创建存储过程</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称([参数列表])<br><span class="hljs-keyword">BEGIN</span><br><span class="hljs-comment">-- 一系列SQL语句</span><br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>调用存储过程</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> 存储过程名称([参数列表]);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>查看存储过程</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查询指定数据库的存储过程及状态信息</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> INFORMATION_SCHEMA.ROUTINES <span class="hljs-keyword">WHERE</span> ROUTINE_SCHEMA <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;数据库名&#x27;</span>;<br><br><span class="hljs-comment">-- 查询指定存储过程的创建信息</span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名称;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删除存储过程</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> [IF <span class="hljs-keyword">EXISTS</span>] 存储过程名称;<br></code></pre></td></tr></table></figure>

<h4 id="4-2-2-变量"><a href="#4-2-2-变量" class="headerlink" title="4.2.2 变量"></a>4.2.2 变量</h4><ol>
<li><strong>系统变量</strong></li>
</ol>
<p>系统变量是MySQL服务器提供的变量，可分为全局变量（<code>GLOBAL</code>）和会话变量（<code>SESSION</code>）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 系统变量有关的SQL语句</span><br><br><span class="hljs-comment">-- 1. 查看系统变量</span><br><span class="hljs-keyword">SHOW</span> [SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>] VARIABLES;<br><span class="hljs-keyword">SHOW</span> [SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>] VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;....&#x27;</span>; <span class="hljs-comment">-- 可用模糊匹配缩小范围</span><br><span class="hljs-keyword">SELECT</span> @@[SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>].系统变量名; <span class="hljs-comment">-- 精确查找</span><br><br><span class="hljs-comment">-- 2. 设置系统变量</span><br><span class="hljs-keyword">SET</span> [SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>] 系统变量名 <span class="hljs-operator">=</span> 值;<br><span class="hljs-keyword">SET</span> @@[SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>].系统变量名 <span class="hljs-operator">=</span> 值; <br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>在MySQL服务器重新启动后，全局变量会恢复默认设置，如果希望永久改变，需要修改MySQL的配置文件。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>如果省略<code>SESSION</code>&#x2F;<code>GLOBAL</code>，则默认为<code>SESSION</code>。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>用户定义变量</strong></li>
</ol>
<p>用户定义变量，即用户根据需要自己定义的变量；用户定义变量无需声明，直接使用<code>@变量名</code>即可，如未赋值，默认为<code>NULL</code>；<strong>用户定义变量的作用域为当前会话</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 用户定义变量相关SQL</span><br><br><span class="hljs-comment">-- 使用SET进行赋值</span><br><span class="hljs-keyword">SET</span> @变量名 <span class="hljs-operator">=</span> expr [, @变量名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> expr2] ... ;<br><span class="hljs-keyword">SET</span> @变量名 :<span class="hljs-operator">=</span> expr [, @变量名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> expr2] ... ;<br><br><span class="hljs-comment">-- 使用SELECT进行赋值</span><br><br><span class="hljs-keyword">SELECT</span> @变量名 :<span class="hljs-operator">=</span> expr [, @变量名<span class="hljs-number">2</span> <span class="hljs-operator">=</span> expr2] ... ;<br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> @变量名 <span class="hljs-keyword">FROM</span> 表名 ... ; <span class="hljs-comment">-- 从表中读取某个数据（必须是单个值）到自定义的变量中</span><br><br><span class="hljs-comment">-- 使用自定义变量</span><br><span class="hljs-keyword">SELECT</span> @变量名;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>局部变量</strong></li>
</ol>
<p>局部变量是根据需要定义的在局部生效的变量；局部变量之前需要进行声明；局部变量用于存储过程内的局部变量和输入参数，作用范围是其声明语句所在的<code>BEGIN...END</code>块。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 局部变量相关SQL</span><br><br><span class="hljs-comment">-- 声明语句</span><br><span class="hljs-keyword">DECLARE</span> 局部变量名 变量类型 [<span class="hljs-keyword">DEFAULT</span> 默认值];<br><span class="hljs-comment">-- 变量类型的范围和数据库字段类型一致：包括INT、BIGINT、CHAR、VARCHAR等</span><br><span class="hljs-comment">-- 未声明默认值，默认为NULL</span><br><br><span class="hljs-comment">-- 赋值</span><br><span class="hljs-keyword">SET</span> 变量名 <span class="hljs-operator">=</span> 值;<br><span class="hljs-keyword">SET</span> 变量名 :<span class="hljs-operator">=</span> 值;<br><span class="hljs-keyword">SELECT</span> 字段名 <span class="hljs-keyword">INTO</span> 变量名 <span class="hljs-keyword">FROM</span> 表名 ... ;<br></code></pre></td></tr></table></figure>

<h4 id="4-2-3-参数"><a href="#4-2-3-参数" class="headerlink" title="4.2.3 参数"></a>4.2.3 参数</h4><p>在定义存储过程的时候，可以指定参数，在参数列表中声明参数时，需要声明参数的类型，包括<code>IN</code>、<code>OUT</code>、<code>INOUT</code>三种类型。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>IN</code></td>
<td>该类参数作为输入（默认类型）</td>
</tr>
<tr>
<td><code>OUT</code></td>
<td>该类参数作为输出，即作为返回值</td>
</tr>
<tr>
<td><code>INOUT</code></td>
<td>既可以作为输入参数，也可以作为输出参数</td>
</tr>
</tbody></table>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名([<span class="hljs-keyword">IN</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">OUT</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">INOUT</span>] 参数名 参数类型, ....)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-comment">-- SQL语句</span><br>  <span class="hljs-comment">-- 将结果存储在OUT类型的参数中</span><br><span class="hljs-keyword">END</span>;<br><br><br><span class="hljs-keyword">CALL</span> 存储过程名(参数列表); <br><span class="hljs-comment">-- 参数列表要和创建存储过程的参数列表顺序一致</span><br><span class="hljs-comment">-- 对于IN类型，可以直接传入值或赋值后的自定义变量；</span><br><span class="hljs-comment">-- 对于OUT类型，可以传入一个用户自定义变量用于接收返回值</span><br><span class="hljs-comment">-- 对于INOUT类型，可以传入一个赋值后的用户自定义变量，同时接收返回值</span><br></code></pre></td></tr></table></figure>

<h4 id="4-2-4-分支语句"><a href="#4-2-4-分支语句" class="headerlink" title="4.2.4 分支语句"></a>4.2.4 分支语句</h4><ul>
<li><strong>IF</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<br><span class="hljs-keyword">BEGIN</span><br>  IF 条件<span class="hljs-number">1</span> <span class="hljs-keyword">THEN</span><br>    ...;<br>  ELSEIF 条件<span class="hljs-number">2</span> <span class="hljs-keyword">THEN</span><br>    ...;<br>  <span class="hljs-keyword">ELSE</span><br>    ...;<br>  <span class="hljs-keyword">END</span> IF;<br><span class="hljs-keyword">END</span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>CASE</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 与sql基础语句的CASE结构类似</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-keyword">CASE</span> val  <span class="hljs-comment">--依次比较val和WHEN后的值，如果相等则走对应分支</span><br>    <span class="hljs-keyword">WHEN</span> val1 <span class="hljs-keyword">THEN</span> <br>    ....;<br>    <span class="hljs-keyword">WHEN</span> val2 <span class="hljs-keyword">THEN</span><br>    ....;<br>    <span class="hljs-keyword">ELSE</span><br>    ....;<br>  <span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><span class="hljs-keyword">END</span>;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-comment">-- 依次计算expr1、expr2...，某个为真则走对应分支</span><br>  <span class="hljs-comment">-- 只会走第一个为真的分支</span><br>  <span class="hljs-keyword">CASE</span>  <br>    <span class="hljs-keyword">WHEN</span> expr1 <span class="hljs-keyword">THEN</span> <br>    ....;<br>    <span class="hljs-keyword">WHEN</span> expr2 <span class="hljs-keyword">THEN</span><br>    ....;<br>    <span class="hljs-keyword">ELSE</span><br>    ....;<br>  <span class="hljs-keyword">END</span> <span class="hljs-keyword">CASE</span>;<br><span class="hljs-keyword">END</span>;<br><br></code></pre></td></tr></table></figure>
<h4 id="4-2-5-循环语句"><a href="#4-2-5-循环语句" class="headerlink" title="4.2.5 循环语句"></a>4.2.5 循环语句</h4><ul>
<li><strong>WHILE</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<br><span class="hljs-keyword">BEGIN</span><br>  WHILE 条件 DO<br>    ...<br>  <span class="hljs-keyword">END</span> WHILE<br><span class="hljs-keyword">END</span>;<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>REPEAT</strong></li>
</ul>
<p>相当于<code>do-while</code>循环。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<br><span class="hljs-keyword">BEGIN</span><br>  REPEAT <br>    ...<br>    UNTIL 条件<br>  <span class="hljs-keyword">END</span> REPEAT<br><span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>LOOP</strong></li>
</ul>
<p>可用作无限循环，相当于<code>While(true){}</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> 存储过程名(参数列表)<br><span class="hljs-keyword">BEGIN</span><br>  [begin_label:] LOOP<br>    ...<br>  <span class="hljs-keyword">END</span> LOOP [end_label];<br><span class="hljs-keyword">END</span>;<br><br></code></pre></td></tr></table></figure>

<p>以下两条语句可用在LOOP的循环体中，相当于<code>break</code>和<code>continue</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">LEAVE label;<br>ITERATE label;<br></code></pre></td></tr></table></figure>

<p>注意，这里的<code>begin_label</code>用于标识循环块开始的地方，如果要写<code>end_label</code>，则<code>end_label</code>必须与对应的<code>begin_label</code>相同。</p>
<h4 id="4-2-6-游标"><a href="#4-2-6-游标" class="headerlink" title="4.2.6 游标"></a>4.2.6 游标</h4><p>游标（<code>CURSOR</code>）是用来<strong>存储查询结果集</strong>的数据类型，在存储过程&#x2F;存储函数中可以使用游标对结果集进行循环的处理。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 游标相关SQL</span><br><span class="hljs-comment">-- 声明游标</span><br><span class="hljs-keyword">DECLARE</span> 游标名称 <span class="hljs-keyword">CURSOR</span> <span class="hljs-keyword">FOR</span> 查询语句; <span class="hljs-comment">-- 将&#x27;查询语句&#x27;的返回结果存储到&#x27;游标名称&#x27;对应的游标中。</span><br><br><span class="hljs-comment">-- 打开游标</span><br><span class="hljs-keyword">OPEN</span> 游标名称; <span class="hljs-comment">-- 只有打开游标之后，才能从中读取数据</span><br><br><span class="hljs-comment">-- 获取游标记录</span><br><span class="hljs-keyword">FETCH</span> 游标名称 <span class="hljs-keyword">INTO</span> 变量名<span class="hljs-number">1</span>, [变量名<span class="hljs-number">2</span>]; <span class="hljs-comment">-- 每次读取一行的数据，按字段存入指定的变量中</span><br><br><span class="hljs-comment">-- 关闭游标</span><br><span class="hljs-keyword">CLOSE</span> 游标名称<br><br></code></pre></td></tr></table></figure>

<h4 id="4-2-7-条件处理程序"><a href="#4-2-7-条件处理程序" class="headerlink" title="4.2.7 条件处理程序"></a>4.2.7 条件处理程序</h4><p>条件处理程序（<code>HANDLER</code>）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤；例如，在<code>WHILE</code>循环中读取游标的值，判断游标读取完毕就需要用到<code>HANDLER</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 条件处理程序相关SQL</span><br><span class="hljs-keyword">DECLARE</span> 处理动作 HANDLER <span class="hljs-keyword">FOR</span> 状态码 处理语句<br><br><span class="hljs-comment">-- 当捕获到指定状态码，执行处理语句，最后进行处理动作</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>状态码</strong></li>
</ul>
<p>可以使用<code>SQLSTATE</code>关键字加上状态码的形式，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQLSTATE</span> <span class="hljs-string">&#x27;02000&#x27;</span><br></code></pre></td></tr></table></figure>

<p>对应一些特定的状态码，可以用专属的关键字，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQLWARNING</span> <span class="hljs-comment">-- 所有以01开头的SQLSTATE代码的简写</span><br><span class="hljs-keyword">NOT</span> FOUND <span class="hljs-comment">-- 所有以02开头的SQLSTATE代码的简写</span><br><span class="hljs-keyword">SQLEXCEPTION</span> <span class="hljs-comment">-- 所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE代码的简写</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>处理动作</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">CONTINUE <span class="hljs-comment">-- 继续执行当前存储程序（如当前的存储过程/存储函数）</span><br>EXIT <span class="hljs-comment">-- 终止执行当前存储程序</span><br></code></pre></td></tr></table></figure>

<h4 id="4-2-8-存储过程示例代码"><a href="#4-2-8-存储过程示例代码" class="headerlink" title="4.2.8 存储过程示例代码"></a>4.2.8 存储过程示例代码</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 从user表中读出小于指定年龄的记录的id和name，存入另一张表user_name中。</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span> IF <span class="hljs-keyword">EXISTS</span> p;<br><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> p(<span class="hljs-keyword">IN</span> age <span class="hljs-type">INT</span>)<br><span class="hljs-keyword">BEGIN</span><br>    <span class="hljs-keyword">DECLARE</span> id <span class="hljs-type">INT</span>;<br>    <span class="hljs-keyword">DECLARE</span> name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">DECLARE</span> flag <span class="hljs-type">INT</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 用于控制循环是否继续</span><br>    <span class="hljs-keyword">DECLARE</span> cursor_id_name <span class="hljs-keyword">CURSOR</span><br>        <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">SELECT</span> user.id, user.name<br>            <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br>            <span class="hljs-keyword">WHERE</span> user.age <span class="hljs-operator">&lt;</span> age;<br>    <span class="hljs-keyword">DECLARE</span> continue HANDLER <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">NOT</span> FOUND <span class="hljs-keyword">SET</span> flag <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> user_name;<br>    <span class="hljs-keyword">CREATE TABLE</span> user_name (<br>      id <span class="hljs-type">INT</span>,<br>      name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>)<br>    );<br><br>    <span class="hljs-keyword">OPEN</span> cursor_id_name;<br>    insert_loop: LOOP<br>        <span class="hljs-keyword">FETCH</span> cursor_id_name <span class="hljs-keyword">INTO</span> id, name;<br>        IF FLAG <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-keyword">THEN</span><br>            LEAVE insert_loop;<br>        <span class="hljs-keyword">END</span> IF;<br>        <span class="hljs-keyword">INSERT INTO</span> user_name <span class="hljs-keyword">VALUES</span>(id, name);<br>    <span class="hljs-keyword">END</span> LOOP insert_loop;<br>    <span class="hljs-keyword">CLOSE</span> cursor_id_name;<br><span class="hljs-keyword">end</span>;<br><br><span class="hljs-keyword">CALL</span> p(<span class="hljs-number">22</span>);<br><br></code></pre></td></tr></table></figure>

<h3 id="4-3-存储函数"><a href="#4-3-存储函数" class="headerlink" title="4.3 存储函数"></a>4.3 存储函数</h3><p>存储函数具有返回值，存储函数的参数只能是<code>IN</code>类型的，调用的时候像普通函数一样使用，无需通过<code>CALL</code>调用。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">FUNCTION</span> 存储函数名称([参数列表])<br><span class="hljs-keyword">RETURNS</span> 参数类型 [<span class="hljs-keyword">DETERMINISTIC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span> <span class="hljs-keyword">SQL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">READS</span> <span class="hljs-keyword">SQL</span> DATA]<br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-comment">-- SQL语句</span><br>  <span class="hljs-keyword">RETURN</span> ... <span class="hljs-operator">=</span>;<br><span class="hljs-keyword">END</span>;<br><br><span class="hljs-comment">-- 参数类型说明</span><br><span class="hljs-comment">-- 使用MySQL支持的数据类型</span><br><br><span class="hljs-comment">-- characteristic参数说明</span><br><br><span class="hljs-comment">-- 1. DETERMINISTIC: 相同的输入参数总是产生相同的结果；</span><br><span class="hljs-comment">-- 2. NO SQL: 不包含SQL语句；</span><br><span class="hljs-comment">-- 3. READS SQL DATA: 包含读取数据的语句，但不包含写入数据的语句。</span><br></code></pre></td></tr></table></figure>

<h3 id="4-4-触发器"><a href="#4-4-触发器" class="headerlink" title="4.4 触发器"></a>4.4 触发器</h3><ul>
<li><strong>定义</strong></li>
</ul>
<p>触发器定义在数据库的层面，在数据库中针对于某个表发生了<strong>增&#x2F;删&#x2F;改</strong>操作<strong>前&#x2F;后</strong>，会触发并执行触发器中定义的SQL语句集合。在MySQL中，只支持<strong>行级触发</strong>：指的是在一条增&#x2F;删&#x2F;改语句执行后，针对于被影响的每一行数据，都会触发一次触发器。</p>
<ul>
<li><strong>作用</strong></li>
</ul>
<p>触发器可以用于在数据库端确保数据的完整性、日志记录、数据校验等操作。</p>
<ul>
<li><strong>SQL语法</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建触发器</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> 触发器名<br>BEFORE<span class="hljs-operator">/</span>AFTER <span class="hljs-keyword">INSERT</span><span class="hljs-operator">/</span><span class="hljs-keyword">UPDATE</span><span class="hljs-operator">/</span><span class="hljs-keyword">DELETE</span><br><span class="hljs-keyword">ON</span> 表名 <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-type">ROW</span> <span class="hljs-comment">-- 行级触发器</span><br><span class="hljs-keyword">BEGIN</span><br>  <span class="hljs-comment">-- 触发器被触发后执行的语句</span><br><span class="hljs-keyword">END</span>;<br><br><span class="hljs-comment">-- 查看当前数据库存在的触发器</span><br><span class="hljs-keyword">SHOW</span> TRIGGERS;<br><br><span class="hljs-comment">-- 删除指定数据库的触发器</span><br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> [数据库名.]触发器名; <span class="hljs-comment">-- 未指定数据库名则默认为当前数据库</span><br></code></pre></td></tr></table></figure>

<p>在编写触发器被触发后执行的语句时，可以通过<code>NEW</code>和<code>OLD</code>关键字指代数据行，可以通过<code>NEW/OLD.字段名</code>的形式读取一行的某个字段，对于不同的DML语句，其<code>NEW</code>、<code>OLD</code>的含义如下表所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th><code>NEW</code></th>
<th><code>OLD</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>INSERT</code></td>
<td>被插入的行记录</td>
<td>~</td>
</tr>
<tr>
<td><code>DELETE</code></td>
<td>~</td>
<td>被删除的行记录</td>
</tr>
<tr>
<td><code>UPDATE</code></td>
<td>更新后的行记录</td>
<td>更新前的行记录</td>
</tr>
</tbody></table>
<h2 id="5-事务与并发控制"><a href="#5-事务与并发控制" class="headerlink" title="5. 事务与并发控制"></a><strong>5. 事务与并发控制</strong></h2><h3 id="5-1-事务基础"><a href="#5-1-事务基础" class="headerlink" title="5.1 事务基础"></a>5.1 事务基础</h3><h4 id="5-1-1-事务概念"><a href="#5-1-1-事务概念" class="headerlink" title="5.1.1 事务概念"></a>5.1.1 事务概念</h4><p>事务是一组逻辑上不可分割的操作集合，要么全部成功，要么全部失败，并且对系统状态的影响是可控、可恢复、可隔离的。</p>
<h4 id="5-1-2-手动操作事务"><a href="#5-1-2-手动操作事务" class="headerlink" title="5.1.2 手动操作事务"></a>5.1.2 手动操作事务</h4><p>在<code>MySQL</code>中使用事务进行操作，可以用两种方式。</p>
<ol>
<li><strong>手动提交事务</strong></li>
</ol>
<p>在<code>MySQL</code>中，默认事务是自动提交的：即执行一条<code>DML</code>语句后，<code>MySQL</code>会立即隐式地提交任务，可以通过查看其系统参数<code>@@autocommit</code>得知。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@autocommit</span>; <span class="hljs-comment">-- 默认为1，即自动提交事务</span><br></code></pre></td></tr></table></figure>

<p>可以将事务提交设置为手动。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">-- 在当前console中生效</span><br></code></pre></td></tr></table></figure>

<p>随后可以进行事务的提交和回滚。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>开启事务</strong></li>
</ol>
<p>不改变事务的自动提交参数也可以通过开启事务的方式操作事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;  <span class="hljs-comment">-- 其后的多句sql作为一个事务</span><br><span class="hljs-keyword">BEGIN</span>;<br></code></pre></td></tr></table></figure>

<p>随后进行手动提交&#x2F;回滚，操作与之前相同。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><br><span class="hljs-comment">-- 回滚事务</span><br><span class="hljs-keyword">ROLLBACK</span>;<br></code></pre></td></tr></table></figure>
<h4 id="5-1-3-事务四大特性ACID"><a href="#5-1-3-事务四大特性ACID" class="headerlink" title="5.1.3 事务四大特性ACID"></a>5.1.3 事务四大特性<code>ACID</code></h4><ul>
<li><strong>原子性（Atomicity）</strong>：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li>
<li><strong>一致性（Consistency）</strong>：事务完成时，必须使所有的数据都保持一致状态。</li>
<li><strong>隔离性（Isolation）</strong>：数据库系统提供的隔离机制，保证每个事务都在独立的环境下运行，不会受到外部并发操作的影响。</li>
<li><strong>持久性（Durability）</strong>：事务一旦提交或回滚，它对数据库中数据的改变就是永久的（即保存到了文件当中）。</li>
</ul>
<h3 id="5-2-并发事务"><a href="#5-2-并发事务" class="headerlink" title="5.2 并发事务"></a>5.2 并发事务</h3><p>为提高数据库系统的操作效率，数据库系统允许多个事务之间进行并发操作，并设置了不同的隔离级别，提高操作效率的同时，可能会产生并发导致的问题。</p>
<h4 id="5-2-1-并发事务存在的问题"><a href="#5-2-1-并发事务存在的问题" class="headerlink" title="5.2.1 并发事务存在的问题"></a>5.2.1 并发事务存在的问题</h4><p>以下问题均出现在两个事务A、B并发执行且访问同一张表的相关数据的情况下，且不同的隔离级别会避免其中的一些&#x2F;全部问题。</p>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>问题说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>脏读</strong></td>
<td>事务A读取到了事务B未提交的数据，而随后事务B执行回滚，则事务A读到的数据即为脏数据。</td>
</tr>
<tr>
<td><strong>不可重复读</strong></td>
<td>事务A多次读取同一数据，而事务B在事务A多次读取的间隙中修改了该数据，导致事务A多次读取同一数据的结果不一致。</td>
</tr>
<tr>
<td><strong>幻读</strong></td>
<td>事务A读取了几行数据后，事务B插入了一些新数据；随后的查询中，事务A可能查询到一些原本不存在的记录。</td>
</tr>
</tbody></table>
<ul>
<li><strong>脏读复现</strong></li>
</ul>
<blockquote>
<p>使用<code>MySQL</code>手动模拟并发，对于以上三类问题进行简单的说明，可在阅读完后一节<a href="#522-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">隔离级别</a>后再来看这部分复现内容：</p>
</blockquote>
<p>假设现在使用的数据库中有一张表<code>users</code>，包含主键<code>id</code>、<code>name</code>、<code>money</code>三个属性。在两个命令行窗口中使用MySQL客户端，执行如下指令。</p>
<table>
<thead>
<tr>
<th>命令行1</th>
<th>命令行2</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SET SESSION TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</code></td>
<td>~</td>
<td>将事务A的隔离级别设置为<code>READ UNCOMMITTED</code>。</td>
</tr>
<tr>
<td><code>START TRANSACTION;</code></td>
<td><code>START TRANSACTION;</code></td>
<td>开启两个事务，分别对应事务A和事务B。</td>
</tr>
<tr>
<td><code>SELECT * FROM users;</code></td>
<td>~</td>
<td>模拟事务A第一条SQL。</td>
</tr>
<tr>
<td>~</td>
<td><code>UPDATE users SET money = money - 2000 WHERE name = &#39;Jack&#39;;</code></td>
<td>模拟事务B第一条SQL，更新了数据，但<strong>尚未提交</strong>。</td>
</tr>
<tr>
<td><code>SELECT * FROM users;</code></td>
<td>~</td>
<td>模拟事务A第二条SQL，此时事务A能够读取到被更新的数据（即B事务更改但未提交的数据），因为这是<code>READ UNCOMMITTED</code>决定的，从而出现脏读。</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>后续操作省略。</td>
</tr>
</tbody></table>
<ul>
<li><strong>不可重复读复现</strong></li>
</ul>
<table>
<thead>
<tr>
<th>命令行1</th>
<th>命令行2</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></td>
<td>~</td>
<td>将事务A的隔离级别设置为<code>READ COMMITTED</code>。</td>
</tr>
<tr>
<td><code>START TRANSACTION;</code></td>
<td><code>START TRANSACTION;</code></td>
<td>开启两个事务，分别对应事务A和事务B。</td>
</tr>
<tr>
<td><code>SELECT * FROM users;</code></td>
<td>~</td>
<td>模拟事务A第一条SQL。</td>
</tr>
<tr>
<td>~</td>
<td><code>UPDATE users SET money = money - 2000 WHERE name = &#39;Jack&#39;;</code></td>
<td>模拟事务B第一条SQL，更新了数据，但<strong>尚未提交</strong>。</td>
</tr>
<tr>
<td><code>SELECT * FROM users;</code></td>
<td>~</td>
<td>模拟事务A第二条SQL，此时事务A不能读取到更改的数据，因为事务B未提交，避免了脏读。</td>
</tr>
<tr>
<td>~</td>
<td><code>COMMIT;</code></td>
<td>事务B提交。</td>
</tr>
<tr>
<td><code>SELECT * FROM users;</code></td>
<td>~</td>
<td>模拟事务A第三条SQL，此时事务A读取到了更改的数据，因为事务B已提交，与第一次读取结果不一致，出现不可重复读问题。</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>后续操作省略。</td>
</tr>
</tbody></table>
<ul>
<li><strong>幻读复现</strong></li>
</ul>
<blockquote>
<p>MySQL InnoDB 在<code>REPEATABLE READ</code>下使用 MVCC + next-key&#x2F;gap Lock：普通<code>SELECT</code>读到固定快照、<code>SELECT ... FOR UPDATE</code> 会阻止范围内插入。因此即便在 RR 级别故意穿插插入，也观察不到“前后两次读取的行集不同”的经典幻读现象。为了复现幻读，需要降低隔离到<code>READ COMMITTED</code>（或禁用 gap Lock），让当前读无法锁住范围，才能看到新插入的“幻行”：</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令行1</th>
<th>命令行2</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;</code></td>
<td>~</td>
<td>将事务A的隔离级别设置为<code>READ COMMITTED</code>（不使用Gap Lock）。</td>
</tr>
<tr>
<td><code>START TRANSACTION;</code></td>
<td><code>START TRANSACTION;</code></td>
<td>分别开启事务A、事务B。</td>
</tr>
<tr>
<td><code>SELECT * FROM users WHERE money &gt;= 0 FOR UPDATE;</code></td>
<td>~</td>
<td>事务A进行第一次当前读，锁住当前满足条件的行集。</td>
</tr>
<tr>
<td>~</td>
<td><code>INSERT INTO users VALUES (NULL, &#39;Tony&#39;, 0);</code></td>
<td>事务B插入一条满足上述条件的新记录。</td>
</tr>
<tr>
<td>~</td>
<td><code>COMMIT;</code></td>
<td>事务B提交，插入生效。</td>
</tr>
<tr>
<td><code>SELECT * FROM users WHERE money &gt;= 0 FOR UPDATE;</code></td>
<td>~</td>
<td>事务A第二次当前读会返回比第一次更多的记录，看到了事务B插入的“幻行”。</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
<td>后续操作省略。</td>
</tr>
</tbody></table>
<h4 id="5-2-2-隔离级别"><a href="#5-2-2-隔离级别" class="headerlink" title="5.2.2 隔离级别"></a>5.2.2 隔离级别</h4><ul>
<li><strong>隔离级别分类</strong></li>
</ul>
<p>为在并发的效率与产生的问题之间达到平衡，数据库提供不同等级的隔离级别供开发者使用：从上至下，隔离级别越高，安全性越高，效率越低。</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>READ UNCOMMITTED</code></td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>设置该隔离级别的会话中的事务可以读取并发事务尚未提交的数据。在实际开发中使用少，对数据一致性的保护太弱。</td>
</tr>
<tr>
<td><code>READ COMMITTED</code></td>
<td>×</td>
<td>√</td>
<td>√</td>
<td>设置该隔离级别的会话中的事务只能读取并发事务已提交的数据。 这是大多数数据库（Oracle、SQL Server）的默认隔离级别。</td>
</tr>
<tr>
<td><code>REPEATABLE READ</code></td>
<td>×</td>
<td>×</td>
<td>√（<strong>MySQL InnoDB引擎中 ×</strong>）</td>
<td>设置该隔离级别的会话中的事务能够保证在该事务中读取同一数据的结果能保持一致（除非自己修改）；这是MySQL的默认隔离级别，另外在MySQL InnoDB存储引擎中，通过MVCC和锁机制，同样几乎解决了幻读问题。</td>
</tr>
<tr>
<td><code>SERIALIZABLE</code></td>
<td>×</td>
<td>×</td>
<td>×</td>
<td>完全服从ACID的隔离级别，串行化处理，安全性极高，但效率低 。</td>
</tr>
</tbody></table>
<ul>
<li><strong>查看与设置隔离级别</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看当前会话的隔离级别</span><br><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@TRANSACTION_ISOLATION</span>;<br><br><span class="hljs-comment">-- 设置隔离级别</span><br><span class="hljs-keyword">SET</span> &#123;SESSION <span class="hljs-operator">|</span> <span class="hljs-keyword">GLOBAL</span>&#125; <br>TRANSACTION ISOLATION LEVEL <br>&#123;READ UNCOMMITTED <span class="hljs-operator">|</span> READ COMMITTED <span class="hljs-operator">|</span> REPEATABLE READ <span class="hljs-operator">|</span> SERIALIZABLE&#125;;<br></code></pre></td></tr></table></figure>
<h3 id="5-3-锁"><a href="#5-3-锁" class="headerlink" title="5.3 锁"></a>5.3 锁</h3><blockquote>
<p>本节与下一节的内容处理并发事务的解决方案均为<a href="#63-innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E8%AF%A6%E8%A7%A3"><code>InnoDB</code>引擎</a>的解决方案。</p>
</blockquote>
<p>在数据库中，通过锁机制保证<strong>数据库中的数据被多个事务并发访问的一致性、有效性</strong>，可从不同的角度对锁进行分类：</p>
<ol>
<li><strong>按照锁的作用范围分</strong>：</li>
</ol>
<ul>
<li>全局锁：锁定数据库中的所有表。</li>
<li>表级锁：每次操作锁住整张表。</li>
<li>行级锁：每次操作锁住对应的行数据。</li>
</ul>
<ol start="2">
<li><strong>按照锁模式分</strong>：</li>
</ol>
<ul>
<li>共享锁（读锁、<code>S</code>）：多个读锁可以并行（兼容），和写锁不兼容。</li>
<li>排他锁（写锁、<code>X</code>）：写锁与任何类型的锁都不兼容。</li>
</ul>
<ol start="3">
<li><strong>按照锁所在层次分</strong>：</li>
</ol>
<ul>
<li>服务层：在服务层实现的锁机制，如全局锁、（显式）表锁、元数据锁等，不同的存储引擎都可以使用这些锁。</li>
<li>存储引擎层：由存储引擎自己实现的锁机制，如<code>InnoDB</code>的行锁、<code>InnoDB</code>的意向锁、<code>MyISAM</code>的表锁等。</li>
</ul>
<h4 id="5-3-1-全局锁"><a href="#5-3-1-全局锁" class="headerlink" title="5.3.1 全局锁"></a>5.3.1 全局锁</h4><p>全局锁对整个数据库实例进行加锁，加锁后<strong>整个实例就处于只读状态</strong>，属于<strong>全局共享锁</strong>；其目的是阻塞了一切的写语句（DML、DDL），<strong>保证整个数据库只能被读取、不能被修改</strong>；全局锁<strong>常用于对数据库做备份</strong>，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加全局锁</span><br>FLUSH TABLES <span class="hljs-keyword">WITH</span> READ LOCK;<br><br><span class="hljs-comment">-- 释放锁</span><br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure>

<h4 id="5-3-2-表级锁"><a href="#5-3-2-表级锁" class="headerlink" title="5.3.2 表级锁"></a>5.3.2 表级锁</h4><p>表级锁，每次操作锁住整张表，主要分为三类：表锁、元数据锁、意向锁。</p>
<h5 id="5-3-2-1-表锁"><a href="#5-3-2-1-表锁" class="headerlink" title="5.3.2.1 表锁"></a>5.3.2.1 表锁</h5><p>表锁是用于控制并发事务对于表中数据操作的锁，可分为表读锁（表共享锁）、表写锁（表排他锁）两类。</p>
<blockquote>
<p>（显式）表锁（LOCK TABLES）是MySQL<strong>服务器层提供的通用功能</strong>，各存储引擎都可以用，但只在“主动写出来”时才生效。</p>
</blockquote>
<ul>
<li><strong>语法</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 加锁</span><br>LOCK TABLES 表名 READ<span class="hljs-operator">/</span>WRITE;<br><br><span class="hljs-comment">-- 释放锁</span><br>UNLOCK TABLES;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>作用</strong></li>
</ul>
<table>
<thead>
<tr>
<th>对某表使用表锁类型</th>
<th>当前事务</th>
<th>并行事务</th>
</tr>
</thead>
<tbody><tr>
<td><strong>表读锁</strong></td>
<td>可以读取表中数据，修改表中数据会报错。</td>
<td>可以读取表中数据，修改表中数据会阻塞。</td>
</tr>
<tr>
<td><strong>表写锁</strong></td>
<td>可以读取表中数据，可以修改表中数据。</td>
<td>读取表中数据、修改表中数据均会被阻塞。</td>
</tr>
</tbody></table>
<blockquote>
<p>表读锁与表读锁是兼容的，表写锁与任何锁都不兼容。</p>
</blockquote>
<h5 id="5-3-2-2-元数据锁"><a href="#5-3-2-2-元数据锁" class="headerlink" title="5.3.2.2 元数据锁"></a>5.3.2.2 元数据锁</h5><p>元数据锁（Meta Data Lock，<code>MDL</code>），作用是<strong>维持表元数据的一致性</strong>：在表上有活动事务时，不允许对元数据进行写入操作（如DDL语句中关于表的部分）。</p>
<blockquote>
<ol>
<li>表的元数据：可以简单理解为一张表的表结构，如拥有的字段等。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>在MySQL 5.5中引入了元数据锁，在服务层实现：当某事务对一张表进行增删改查的时候，该事务在该表加<code>MDL</code>读锁（共享锁）；当某事务对表结构进行变更操作时，该事务在该表加<code>MDL</code>写锁（排他锁）。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li><code>MDL</code>共享锁与<code>MDL</code>共享锁之间是兼容的，<code>MDL</code>排他锁与<code>MDL</code>共享锁、<code>MDL</code>排他锁都是互斥的。</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>元数据锁加锁过程是系统自动控制，无需显式使用，在访问一张表的时候就会自动加上。</li>
</ol>
</blockquote>
<h5 id="5-3-2-3-意向锁"><a href="#5-3-2-3-意向锁" class="headerlink" title="5.3.2.3 意向锁"></a>5.3.2.3 意向锁</h5><p>意向锁常指的是<code>InnoDB</code>存储引擎中实现的意向锁，由于<code>InnoDB</code>存储引擎默认使用的是行级锁，如果同时还使用到了表级锁，那么就需要判断所使用的行级锁和表级锁是否兼容&#x2F;互斥，<strong>意向锁的作用就在于简化这一检查过程，使得无需遍历全表的行级锁即可判断</strong>。</p>
<ul>
<li><strong>分类与使用</strong></li>
</ul>
<p>意向锁可分为意向共享锁（Intent Shared lock，<code>IS</code>）和意向排他锁（Intent eXclusive lock，<code>IX</code>）。</p>
<p>在使用特定的DML语句操作表的时候，就会给这张表加上特定的意向锁，如：</p>
<ol>
<li><code>SELECT ... LOCK IN SHARE MODE</code>: 给操作表加意向共享锁。</li>
<li><code>SELECT/INSERT/UPDATE/DELETE ... FOR UPDATE</code>: 给操作表加意向排他锁。</li>
</ol>
<blockquote>
<ol>
<li>普通的<code>SELECT</code>语句，即没有使用<code>LOCK IN SHARE MODE</code>&#x2F;<code>FOR UPDATE</code>的语句，则默认是<strong>快照读</strong>，既不会使用行锁，也不会使用意向锁。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code>即使没有<code>FOR UPDATE</code>也会使用意向排他锁。</li>
</ol>
</blockquote>
<ul>
<li><strong>作用具体说明</strong></li>
</ul>
<p>在加上特定的意向锁后，<strong>某个想要加表级别锁的事务就可以比较意向锁与表级别锁之间的兼容性判断表级别锁是否可以加成功了</strong>，避免了扫描表获取行级别锁的过程，将时间复杂度降低到了<code>O(1)</code>。</p>
<p>具体来说，只有表级别锁和意向锁均为共享锁的情况才能兼容，即加锁成功，其余情况均互斥。</p>
<blockquote>
<p>注意，意向锁之间均是兼容的，一个表可以同时有多个意向共享锁和意向排他锁。</p>
</blockquote>
<h4 id="5-3-3-行级锁"><a href="#5-3-3-行级锁" class="headerlink" title="5.3.3 行级锁"></a>5.3.3 行级锁</h4><p>行级锁，每次操作锁住对应的行数据，应用在<code>InnoDB</code>存储引擎中；由于<code>InnoDB</code>数据的存储结构是通过索引组织的，因此行锁是通过对索引上的索引项加锁来实现的。</p>
<p>行级锁主要分为三类：</p>
<ol>
<li>行锁（<code>Record Lock</code>）：锁定单个行记录的锁，防止其他事务对此行进行<code>UPDATE</code>和<code>DELETE</code>，在<code>RC</code>和<code>RR</code>隔离级别下都支持。</li>
<li>间隙锁（<code>Gap Lock</code>）：锁定索引记录间隙（不含记录），确保索引记录间隙不变，防止其他事务在这个间隙进行<code>INSERT</code>，产生幻读；在<code>RR</code>隔离级别下支持。</li>
<li>临键锁（<code>Next-Key Lock</code>）：行锁和间隙锁组合，同时锁住数据并锁住数据前面（指的是B+数底层的双向链表）的间隙，在<code>RR</code>隔离级别下支持。</li>
</ol>
<ul>
<li><strong>行锁</strong></li>
</ul>
<p>行锁可分为共享锁（<code>S</code>）和排他锁（<code>X</code>），共享锁之间互相兼容，排他锁与共享锁&#x2F;排他锁之间互斥。</p>
<ol>
<li>行共享锁：允许一个事务读取一行数据，同时允许其他事务在该行加共享锁，但不允许其他事务在该行加排他锁。</li>
<li>行排他锁：允许一个事务更新改行数据，同时其他事务都不允许在该行加共享锁&#x2F;排他锁。</li>
</ol>
<ul>
<li><p><code>INSERT/UPDATE/DELETE</code>：自动加行排他锁。</p>
</li>
<li><p><code>SELECT</code>：快照读，不加行锁。</p>
</li>
<li><p><code>SELECT...FOR UPDATE</code>：加行排他锁。</p>
</li>
<li><p><code>SELECT...LOCK IN SHARE MODE</code>：加行共享锁。</p>
</li>
<li><p><strong>实际流程</strong></p>
</li>
</ul>
<p>在<code>RR</code>隔离级别下（MySQL默认隔离级别）运行，<code>InnoDB</code>使用<strong>临键锁（Next-Key Lock）进行搜索和索引扫描，用以防止幻读</strong>，具体情境如下：</p>
<ul>
<li><strong>无可用二级索引</strong>：只能扫描聚簇索引，此时会在聚簇索引上加大量临键锁，效果上接近把整张表锁住，相当于表锁。</li>
<li><strong>存在可用二级索引</strong>：<ul>
<li><strong>唯一索引 + 等值查询 + 记录不存在</strong>：此时临键锁简化为间隙锁（只需要控制这个位置不会被插入即可）</li>
<li><strong>唯一索引 + 等值查询 + 记录存在</strong>：临键锁简化为行锁（只会有这样一条记录，不需要防止插入）</li>
<li><strong>非唯一索引 + 等值查询</strong>：向右遍历到最后一个不满足需求的记录，在最后这个记录前的间隙上使用间隙锁（防止在这个位置继续插入满足条件的记录），所有命中的记录仍使用临键锁。</li>
<li><strong>范围查询</strong>：访问到不满足条件的第一个值为止，在该记录前的间隙上使用间隙锁，所有在范围内的记录使用临键锁。</li>
</ul>
</li>
</ul>
<h3 id="5-4-MVCC、redo-log、undo-log"><a href="#5-4-MVCC、redo-log、undo-log" class="headerlink" title="5.4 MVCC、redo log、undo log"></a>5.4 <code>MVCC</code>、<code>redo log</code>、<code>undo log</code></h3><h4 id="5-4-1-redo-log"><a href="#5-4-1-redo-log" class="headerlink" title="5.4.1 redo log"></a>5.4.1 <code>redo log</code></h4><p>重做日志，记录的是事务提交时数据页的物理修改，用来实现事务的持久性。</p>
<p>日志部分分为两部分，分别位于内存（<code>redo log buffer</code>）和磁盘（<code>redo log file</code>）中。在某个事务中做了一系列修改数据的操作，都会记录在<code>redo log buffer</code>中，在事务提交时，将<code>redo log buffer</code>刷盘至磁盘上的<code>redo log file</code>中进行持久化。</p>
<p>该事务修改数据在内存中产生了一些脏页，由于事务的提交并非伴随着脏页的写回，假设此时系统崩溃，那么内存中的这些脏页便会消失。在系统恢复的时候，就会根据已经持久化的<code>redo log</code>修改内存中的页，再找实际刷回磁盘。</p>
<p><code>redo log</code>的刷盘遵循<strong>WAL（Write-Ahead Logging）</strong>，即如果某个脏页想要刷盘，首先要保证其对应的<code>redo log</code>中的数据已经被刷盘了。</p>
<blockquote>
<ol>
<li>在严格持久性的<code>InnoDB</code>引擎下，如果某个事务被标记为成功提交，则<code>redo log</code>一定已经被成功持久化了。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>在上面的情景中，假设事务未成功提交，系统崩溃了，则会根据<code>redo log</code>进行重放，然后通过<code>undo log</code>回滚。</li>
</ol>
</blockquote>
<h4 id="5-4-2-undo-log"><a href="#5-4-2-undo-log" class="headerlink" title="5.4.2 undo log"></a>5.4.2 <code>undo log</code></h4><p>回滚日志，用于记录数据被修改前的信息，作用为：提供回滚（保证事务的原子性）和实现MVCC（多版本并发控制）。</p>
<p><code>undo log</code>中的日志中的每一条记录为与当前操作逻辑相反的操作，因此回滚时，只需要根据<code>undo log</code>中的语句重新执行则可以恢复操作数据前的数据。<code>undo log</code>在事务执行时产生，事务提交时，不会立即删除<code>undo log</code>，因为这些日志可能还用于MVCC。</p>
<h4 id="5-4-3-MVCC"><a href="#5-4-3-MVCC" class="headerlink" title="5.4.3 MVCC"></a>5.4.3 <code>MVCC</code></h4><ul>
<li><strong>概念</strong></li>
</ul>
<p><code>MVCC</code>（Multi Version Concurrency Control，多版本并发控制）通过数据快照实现了不同事务的<strong>当前读</strong>能够<strong>无锁</strong>地获取不同版本的数据，并且使得快照读、写操作之间不会因为锁的问题而阻塞。</p>
<ul>
<li><strong>作用</strong></li>
</ul>
<p>如果不存在<code>MVCC</code>，系统必须频繁地对读写操作进行加锁来保证数据的正确性，会增加锁的获取和释放的开销，导致整体系统响应速度变慢。</p>
<ul>
<li><strong>原理</strong></li>
</ul>
<p>通过<strong>表中数据的隐藏字段</strong>、<strong>undo log</strong>、<strong>readview</strong>来实现<code>MVCC</code>。</p>
<ol>
<li><strong>隐藏字段</strong></li>
</ol>
<p>首先，表中数据除了自定义的字段外，还会有两个隐藏字段用于实现<code>MVCC</code>:</p>
<table>
<thead>
<tr>
<th>隐藏字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>DB_TRX_ID</code></td>
<td>最近修改事务ID，记录插入这条记录或最后一次修改该记录的事务的ID。</td>
</tr>
<tr>
<td><code>DB_ROLL_PTR</code></td>
<td>回滚指针，指向这条记录的上一个版本（位于<code>undo log</code>中）。</td>
</tr>
</tbody></table>
<ol start="2">
<li><strong>undo log</strong><blockquote>
<p>对于<code>undo log</code>，在<a href="#542-undo-log">上一小节</a>中已经小作介绍了，不过上一节讲的是其数据回滚的功能，这里侧重讲它用于<code>MVCC</code>的功能。</p>
</blockquote>
</li>
</ol>
<p>在事务中出现<code>INSERT</code>、<code>UPDATE</code>和<code>DELETE</code>语句时，会根据反向逻辑记录于<code>undo log</code>中，具体来说：</p>
<ul>
<li><code>INSERT</code>语句：产生的<code>undo log</code>日志只在回滚时需要，在事务提交后即被删除。<blockquote>
<p>因为<code>INSERT</code>之前所谓的旧纪录就是不存在，不会影响<code>MVCC</code>。</p>
</blockquote>
</li>
<li><code>UPDATE</code>&#x2F;<code>DELETE</code>语句：产生的<code>undo log</code>日志不会随着事务提交后就被立刻删除，因为需要用于<code>MVCC</code>。</li>
</ul>
<p>根据对于一条记录的依次删改，则会产生<strong>版本链</strong>，即根据回滚指针字段指向旧记录，从而组成了链表：其中，最新记录作为链表的头部，在链表中位置越靠后代表着越古早的数据。</p>
<ol start="3">
<li><strong>readview</strong></li>
</ol>
<p><strong>readview</strong>是快照读执行时提取数据的依据，其中包含四个核心字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>m_ids</code></td>
<td>当前活跃的事务ID集合（即已开启且未提交的事务）</td>
</tr>
<tr>
<td><code>min_trx_id</code></td>
<td>最小活跃事务ID</td>
</tr>
<tr>
<td><code>max_trx_id</code></td>
<td>预分配事务ID，当前最大事务ID（全局）+1</td>
</tr>
<tr>
<td><code>creator_trx_id</code></td>
<td>ReadView创建者的事务ID（即执行快照读的事务ID）</td>
</tr>
</tbody></table>
<blockquote>
<p>需要补充一下事务ID分配的规则，只有当事务第一次执行<code>INSERT</code>&#x2F;<code>UPDATE</code>&#x2F;<code>DELETE</code>语句时，会为其分配ID，且分配方式是全局递增的形式，理论上只要使用过并提交的事务ID就不会再被复用；假设某个事务只执行过<code>SELECT</code>语句，则它的事务ID一直是0。</p>
</blockquote>
<ol start="4">
<li><strong><code>MVCC</code>核心过程</strong></li>
</ol>
<p>对于选中的某条记录，从最新版本开始，一路沿着版本链往旧版本走，找到<strong>第一个</strong>“对当前事务可见”的版本，如果没有，就当这条记录对当前事务“不存在”。</p>
<p>比较是否可见的方式即：比较<strong>这些字段</strong>与选中的记录的版本链中的每一个结点中的<strong>最近修改事务ID</strong>（我们设为<code>trx_id</code>）的关系，用以判断当前快照读是否能够访问相应版本的数据：</p>
<ul>
<li><code>trx_id</code> &#x3D;&#x3D; <code>creator_trx_id</code>: 可以访问（该版本就是由当前事务修改得到的）</li>
<li><code>trx_id</code> &lt; <code>min_trx_id</code>: 可以访问（造成该版本的事务已经提交）</li>
<li><code>min_trx_id</code> &lt;&#x3D; <code>trx_id</code> &lt;&#x3D; <code>max_trx_id</code>:<ul>
<li><code>trx_id</code> $\in$ <code>m_id</code>: 不可以访问（造成该版本的事务未提交）</li>
<li><code>trx_id</code> $\notin$ <code>m_id</code>：可以访问（造成该版本的事务已经提交）</li>
</ul>
</li>
<li><code>trx_id</code> &gt; <code>max_trx_id</code>: 不可以访问（说明该事务是在readview生成后才开启）</li>
</ul>
<p>对于不同的隔离级别，readview的生成时机不同：</p>
<ul>
<li>RC（READ COMMITTED）: 在事务中每次执行快照读，都会生成readview。</li>
<li>RR（REPEATED READ）：在事务第一次执行快照读的时候生成readview，后续复用该readview。</li>
</ul>
<h2 id="6-MySQL架构与存储引擎"><a href="#6-MySQL架构与存储引擎" class="headerlink" title="6. MySQL架构与存储引擎"></a><strong>6. MySQL架构与存储引擎</strong></h2><h3 id="6-1-MySQL逻辑架构"><a href="#6-1-MySQL逻辑架构" class="headerlink" title="6.1 MySQL逻辑架构"></a>6.1 MySQL逻辑架构</h3><p><img src="/img/MySQL-Notes/MySQL-Ovierview.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="6-1-1-连接层"><a href="#6-1-1-连接层" class="headerlink" title="6.1.1 连接层"></a>6.1.1 连接层</h4><p>不同的语言依据同样的MySQL连接协议开发不同的客户端连接器与MySQL的服务端进行连接，在MySQL的连接层负责进行身份认证和权限认证。</p>
<h4 id="6-1-2-服务层"><a href="#6-1-2-服务层" class="headerlink" title="6.1.2 服务层"></a>6.1.2 服务层</h4><p>服务层完成数据库系统的大多数核心功能。</p>
<ul>
<li><strong>查询缓存</strong></li>
</ul>
<p>执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</p>
<ul>
<li><strong>分析器&#x2F;解析器</strong></li>
</ul>
<p>没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>
<ul>
<li><strong>优化器</strong></li>
</ul>
<p>按照 MySQL 认为最优的方案去执行。</p>
<ul>
<li><strong>执行器</strong></li>
</ul>
<p>执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p>
<h4 id="6-1-3-引擎层"><a href="#6-1-3-引擎层" class="headerlink" title="6.1.3 引擎层"></a>6.1.3 引擎层</h4><p>存储引擎真正地负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。</p>
<p>MySQL中的存储引擎采用<strong>插件式架构</strong>，不同的存储引擎具有不同的功能，支持<code>InnoDB</code>、<code>MyISAM</code>、<code>Memory</code>等多种不同的存储引擎，甚至可以自主编写存储引擎。</p>
<p><code>InnoDB</code>是默认的存储引擎，在绝大多数场景下，使用<code>InnoDB</code>就是最好的选择。</p>
<h4 id="6-1-4-存储层"><a href="#6-1-4-存储层" class="headerlink" title="6.1.4 存储层"></a>6.1.4 存储层</h4><p>主要是将数据存储在文件系统上，并完成与存储引擎的交互。</p>
<h3 id="6-2-存储引擎概览"><a href="#6-2-存储引擎概览" class="headerlink" title="6.2 存储引擎概览"></a>6.2 存储引擎概览</h3><p>存储引擎是数据库管理系统架构中的核心层，是<strong>存储数据、建立索引、更新&#x2F;查询数据</strong>等技术的实现方式。</p>
<h4 id="6-2-1-指定存储引擎"><a href="#6-2-1-指定存储引擎" class="headerlink" title="6.2.1 指定存储引擎"></a>6.2.1 指定存储引擎</h4><p>存储引擎是<strong>基于表</strong>的，也就是说，在同一个数据库的不同表可以使用不同的存储引擎。</p>
<ul>
<li><strong>查看数据库管理系统支持的引擎类型</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> ENGINES;<br></code></pre></td></tr></table></figure>

<p>如在MySQL 8.0.40版本中使用如上语句的查询结果如下所示：</p>
<p><img src="/img/MySQL-Notes/MySQL-engines.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><strong>指定存储引擎</strong></li>
</ul>
<p>在使用建表语句的时候，可以指定表使用的存储引擎类型。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> 表名 (<br>  字段名 字段类型,<br>  ...,<br>  字段名，字段类型<br>) ENGINE <span class="hljs-operator">=</span> 存储引擎类型;<br></code></pre></td></tr></table></figure>

<p>如果没有指定，则默认使用<code>InnoDB</code>作为表的存储引擎。</p>
<h4 id="6-2-2-InnoDB"><a href="#6-2-2-InnoDB" class="headerlink" title="6.2.2 InnoDB"></a>6.2.2 <code>InnoDB</code></h4><p><code>InnoDB</code>是一种兼顾<strong>高可靠性</strong>和<strong>高性能</strong>的通用存储引擎，在MySQL 5.5后作为MySQL的默认存储引擎。</p>
<ul>
<li><strong>特点</strong></li>
</ul>
<ol>
<li><strong>支持事务</strong>：<code>DML</code>操作遵循<code>ACID</code>模型。</li>
<li><strong>使用行级锁</strong>：提高并发访问性能。</li>
<li><strong>支持外键</strong>：支持外键约束，保证数据的完整性和正确性。</li>
</ol>
<ul>
<li><strong>存储文件</strong></li>
</ul>
<p>在MySQL默认开启参数<code>innodb_file_per_table</code>的情况下，使用<code>InnoDB</code>的每张表都会对应一个<strong>表空间文件</strong><code>xxx.ibd</code>，存储<strong>表结构</strong>、<strong>数据</strong>和<strong>索引</strong>。</p>
<h4 id="6-2-3-MyISAM"><a href="#6-2-3-MyISAM" class="headerlink" title="6.2.3 MyISAM"></a>6.2.3 <strong><code>MyISAM</code></strong></h4><p><code>MyISAM</code>是MySQL早期版本的默认存储引擎。</p>
<ul>
<li><strong>特点</strong></li>
</ul>
<ol>
<li>不支持事务。</li>
<li>支持表锁，不支持行锁。</li>
<li>不支持外键约束。</li>
<li>访问速度较快。</li>
</ol>
<ul>
<li><strong>存储文件</strong></li>
</ul>
<p>使用<code>MyISAM</code>作为存储引擎的表，会对应三个文件：</p>
<ol>
<li>xxx.sdi: 存储表结构信息。</li>
<li>xxx.MYD: 存储数据。</li>
<li>xxx.MYI: 存储索引。</li>
</ol>
<h4 id="6-2-4-Memory"><a href="#6-2-4-Memory" class="headerlink" title="6.2.4 Memory"></a>6.2.4 <strong><code>Memory</code></strong></h4><p><code>Memory</code>引擎的<strong>表数据存储在内存</strong>中，由于受到硬件问题、断电问题的影响，只能将这些表作为临时表、缓存使用。</p>
<ul>
<li><strong>特点</strong></li>
</ul>
<ol>
<li>数据存放于内存中，访问速度快。</li>
<li>默认使用哈希索引。</li>
</ol>
<ul>
<li><strong>存储文件</strong></li>
</ul>
<p>使用<code>Memory</code>作为存储引擎的表，对应一个文件：</p>
<ol>
<li>xxx.sdi: 存储表结构信息。</li>
</ol>
<p>表中的数据和索引都存放在内存中，不会存放在磁盘上。</p>
<h4 id="6-2-5-存储引擎对比和选择"><a href="#6-2-5-存储引擎对比和选择" class="headerlink" title="6.2.5 存储引擎对比和选择"></a>6.2.5 存储引擎对比和选择</h4><table>
<thead>
<tr>
<th>特点</th>
<th><code>InnoDB</code></th>
<th><code>MyISAM</code></th>
<th><code>Memory</code></th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td><strong>事务</strong></td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><strong>锁机制</strong></td>
<td>行锁</td>
<td>表锁</td>
<td>表锁</td>
</tr>
<tr>
<td>B+Tree索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Hash索引</td>
<td>-</td>
<td>-</td>
<td>支持</td>
</tr>
<tr>
<td>全文索引</td>
<td>支持（MySQL 5.6版本后）</td>
<td>支持</td>
<td>-</td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>几乎不使用</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><strong>支持外键约束</strong></td>
<td>支持</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>在实际开发中，几乎都会选择<code>InnoDB</code>作为默认存储引擎。</p>
<p><code>MyISAM</code>在实际开发中即使用到，也会选择使用其他<code>NoSQL</code>作为替代；<code>Memory</code>如果要用于缓存，也会优先选择<code>Redis</code>作为解决方案。</p>
<h3 id="6-3-InnoDB存储引擎详解"><a href="#6-3-InnoDB存储引擎详解" class="headerlink" title="6.3 InnoDB存储引擎详解"></a>6.3 <code>InnoDB</code>存储引擎详解</h3><p>在MySQL 5.5之后<code>InnoDB</code>作为默认的存储引擎，便于事务处理，具有崩溃恢复特性，在日常开发中使用广泛。</p>
<h4 id="6-3-1-逻辑存储结构"><a href="#6-3-1-逻辑存储结构" class="headerlink" title="6.3.1 逻辑存储结构"></a>6.3.1 逻辑存储结构</h4><p><img src="/img/MySQL-Notes/innodb-logic-store-structure.png" srcset="/img/loading.gif" lazyload alt="InnoDB逻辑存储结构"></p>
<ol>
<li><strong>表空间（Tablespace）</strong></li>
</ol>
<p><code>InnoDB</code>逻辑存储结构的最高层。</p>
<p>如果用户启用了参数<code>innodb_file_per_table</code>（在MySQL 8.0版本默认开启），则数据库中的每一张表会对应一个表空间（在磁盘上存储为一个<code>.ibd</code>文件）。</p>
<ol start="2">
<li><strong>段（Segment）</strong></li>
</ol>
<p>段可以分为数据段、索引段、回滚段，事实上就是<code>InnoDB</code>在一个索引上，为不同用途的页分的“页集合”。</p>
<ul>
<li>数据段：专门用来存放B+树的叶子节点页。</li>
<li>索引段：专门用来存放B+树的非叶子节点页。</li>
</ul>
<ol start="3">
<li><strong>区（Extent）</strong></li>
</ol>
<p>区是表空间的单元结构，每个区固定大小为1M。默认情况下，<code>InnoDB</code>存储引擎页大小为16K，即在一个区中一共有64个连续的页。</p>
<ol start="4">
<li><strong>页（Page）</strong></li>
</ol>
<p>页是<code>InnoDB</code>存储引擎磁盘管理的最小单元，每个页的大小默认为16K。为了保证页的连续性，<code>InnoDB</code>存储引擎每次从磁盘申请4-5个区。</p>
<ol start="5">
<li><strong>行（ROW）</strong></li>
</ol>
<p><code>InnoDB</code>存储引擎数据是按行进行存放的，在一行中默认有两个隐藏字段：</p>
<ul>
<li><code>Trx_id</code>: 记录最近一次改动该行记录的事务ID。</li>
<li><code>Roll_pointer</code>: 每次改动行记录，将该指针指向改动前的记录内容（改动前的记录内容会被写入<code>undo</code>日志中）。</li>
</ul>
<h4 id="6-3-2-InnoDB系统架构"><a href="#6-3-2-InnoDB系统架构" class="headerlink" title="6.3.2 InnoDB系统架构"></a>6.3.2 <code>InnoDB</code>系统架构</h4><p>从内存和磁盘存储两个方面梳理<code>InnoDB</code>存储引擎的系统架构。</p>
<p><img src="/img/MySQL-Notes/innodb-overview.png" srcset="/img/loading.gif" lazyload alt="InnoDB架构概览"></p>
<h5 id="6-3-2-1-内存架构"><a href="#6-3-2-1-内存架构" class="headerlink" title="6.3.2.1 内存架构"></a>6.3.2.1 内存架构</h5><p><code>InnoDB</code>存储引擎的内存结构可分为四大块：</p>
<ol>
<li><strong>缓冲池（Buffer Pool）</strong></li>
</ol>
<p>缓冲池可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），然后再以一定频率刷新到磁盘，从而减少磁盘I&#x2F;O，加快处理速度。</p>
<p>缓冲池以页（Page）作为单位，采用链表数据结构管理页；有三种状态的页：</p>
<ul>
<li>空闲页（Free Page）：未被使用的页。</li>
<li>干净页（Clean Page）：被使用的页，且该数据并未被修改过。</li>
<li>脏页（Dirty Page）：脏页，被使用的页且数据经过了修改，该页数据与磁盘中对应的数据产生了数据不一致。</li>
</ul>
<blockquote>
<ol>
<li>按照B+树读取并不一定意味着I&#x2F;O开销。通过B+树结构读取实际上就是按照顺序读取一定的页，如果这些页都存在于缓冲池中，则没有额外的I&#x2F;O开销。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>缓冲池中页的组织形式为链表，但本身维护一个哈希表，因此根据页号读取的时间复杂度是<code>O(1)</code>。</li>
</ol>
</blockquote>
<ol start="2">
<li><strong>更改缓冲区（Change Buffer）</strong></li>
</ol>
<p>更改缓冲区针对于<strong>非唯一二级索引</strong>，在执行大量DML语句时，如果这些数据不在缓冲池中，不会直接进行磁盘I&#x2F;O，而是将数据变更存在更改缓冲区中。在未来数据被读取时，再将磁盘中读出的数据与更改记录合并，存入缓冲池中，随后在特定的时刻刷新到磁盘中。</p>
<p>更改缓冲区避免了在更改缓冲池中不存在的页时，立即进行磁盘I&#x2F;O的操作，而是在后续数据被使用（读取）的时候才进行读取、合并及最终写入，减少磁盘I&#x2F;O的次数。</p>
<blockquote>
<p>强调<strong>非唯一</strong>是因为，唯一索引在插入&#x2F;更改数据的时候需要保证数据的唯一性，需要做唯一性检查，因此不能采用这种更改缓冲的机制。</p>
</blockquote>
<ol start="3">
<li><strong>自适应哈希索引（Adaptive Hash Index）</strong></li>
</ol>
<p>自适应哈希索引用于优化对于缓冲池数据的查询，在查找某条记录所在的页号时，可以直接根据<code>AHI</code>得到，无需通过B+树的结构一步一步读取页。自适应哈希索引，无需人工干预，是系统根据情况自动完成。</p>
<p>参数：<code>adaptive_hash_index</code></p>
<ol start="4">
<li><strong>日志缓冲区（Log Buffer）</strong></li>
</ol>
<p>日志缓冲区用来保存要写入到磁盘中的log日志数据（<code>redo log</code>、<code>undo log</code>），默认大小为16MB，日志缓冲区的日志会定期刷新到磁盘中。如果需要更新、插入或删除多行的事务，增加日志缓冲区的大小可以节省磁盘I&#x2F;O。</p>
<p>参数：</p>
<ul>
<li><code>innodb_log_buffer_size</code>：缓冲区大小</li>
<li><code>innodb_flush_log_at_trx_commit</code>：日志刷新到磁盘时机，取值包含以下三个：<ul>
<li><code>0</code>：每秒将日志写入并刷新到磁盘一次。</li>
<li><code>1</code>：日志在每次事务提交时写入并刷新到磁盘。（默认值）</li>
<li><code>2</code>：日志在每次事务提交后写入，并每秒刷新到磁盘一次。</li>
</ul>
</li>
</ul>
<h5 id="6-3-2-2-磁盘架构"><a href="#6-3-2-2-磁盘架构" class="headerlink" title="6.3.2.2 磁盘架构"></a>6.3.2.2 磁盘架构</h5><ol>
<li><strong>系统表空间（System Tablespace）</strong></li>
</ol>
<ul>
<li>更改缓冲区的存储区域。</li>
<li>如果表是在系统表空间而不是每个表文件或通用表空间中创建的，在系统表空间中可能包含表和索引数据。</li>
<li>参数：<code>innodb_data_file_path</code></li>
<li>对应文件：<code>ibdata1</code></li>
</ul>
<blockquote>
<p>更改缓冲区在磁盘上也是以B+树的形式存储，其结点也是页，不过语义与索引生成的B+树不同；在更改缓冲区的B+树上叶子节点对应的页中记录的是某个页需要进行怎样的修改；在系统崩溃的时候，通过磁盘上的更改缓冲区与<code>redo</code>日志恢复内存中更改缓冲区的B+树。</p>
</blockquote>
<ol start="2">
<li><strong>单表空间（File-Per-Table Tablespace）</strong></li>
</ol>
<p>在开启<code>innodb_file_per_table</code>后，每个表的文件表空间包含单个<code>InnoDB</code>表的数据和索引，并存储在文件系统上的单个数据文件中。</p>
<ol start="3">
<li><strong>通用表空间（General Tablespace）</strong></li>
</ol>
<p>使用<code>CREATE TABLESPEACE</code>语法创建的通用表空间，在创建表时，可以指定该表的存储空间。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 创建通用表空间</span><br><br><span class="hljs-keyword">CREATE</span> TABLESPACE 表空间名 <span class="hljs-keyword">ADD</span> DATAFILE <span class="hljs-string">&#x27;xxx.ibd&#x27;</span> ENGINE <span class="hljs-operator">=</span> 存储引擎名;<br><br><span class="hljs-comment">-- 创建表并指定存储表空间</span><br><span class="hljs-keyword">CREATE TABLE</span> 表名(<br>  .....<br>) ENGINE <span class="hljs-operator">=</span> 存储引擎名 TABLESPACE 表空间名;<br><br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>撤销表空间（Undo Tablespaces）</strong></li>
</ol>
<p>MySQL实例在初始化时会自动创建两个默认的<code>undo</code>表空间（初始大小为16M），用于存储<code>undo log</code>日志。</p>
<ol start="5">
<li><strong>临时表空间（Temporary Tablespace）</strong></li>
</ol>
<p><code>InooDB</code>使用会话临时表空间和全局临时表空间；存储用户创建的临时表数据。</p>
<ol start="6">
<li><strong>双写缓冲文件（Doublewrite Buffer Files）</strong></li>
</ol>
<p><code>InnoDB</code>引擎将数据页从内存中的缓冲池刷新到磁盘前，先将数据页写入双写缓冲文件中，便于系统异常时恢复数据。</p>
<ol start="7">
<li><strong>重做日志（Redo Log）</strong></li>
</ol>
<p>用以实现事务的持久性。当事务提交后，把所有修改信息保存到磁盘中的重做日志中，用于在刷新脏页到磁盘发生错误时，进行数据恢复使用。</p>
<h5 id="6-3-2-3-工作线程"><a href="#6-3-2-3-工作线程" class="headerlink" title="6.3.2.3 工作线程"></a>6.3.2.3 工作线程</h5><ol>
<li><strong>Master Thread</strong></li>
</ol>
<p>核心后台线程，负责调度其他线程、将缓冲池中的数据异步刷新到磁盘中（包括脏页的刷新、合并插入缓存、<code>undo</code>页的回收）。</p>
<ol start="2">
<li><strong>IO Thread</strong></li>
</ol>
<p>在<code>InnoDB</code>存储引擎中大量使用了AIO来处理IO请求，<code>IO Thread</code>负责处理这些IO请求的回调，具体可分为以下四类：</p>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>默认个数</th>
<th>职责</th>
</tr>
</thead>
<tbody><tr>
<td>Read Thread</td>
<td>4</td>
<td>负责读操作</td>
</tr>
<tr>
<td>Write Thread</td>
<td>4</td>
<td>负责写操作</td>
</tr>
<tr>
<td>Log Thread</td>
<td>1</td>
<td>负责将日志缓冲区刷新到磁盘</td>
</tr>
<tr>
<td>Insert Buffer Thread</td>
<td>1</td>
<td>负责将写缓冲区内容刷新到磁盘</td>
</tr>
</tbody></table>
<ol start="3">
<li><strong>Purge Thread</strong></li>
</ol>
<p>主要用于回收事务已经提交了的<code>undo log</code>。</p>
<ol start="4">
<li><strong>Page Cleaner Thread</strong></li>
</ol>
<p>协助<code>Master Thread</code>刷新脏页到磁盘的线程。</p>
<h2 id="7-索引与查询优化"><a href="#7-索引与查询优化" class="headerlink" title="7. 索引与查询优化"></a><strong>7. 索引与查询优化</strong></h2><h3 id="7-1-索引概念与分类"><a href="#7-1-索引概念与分类" class="headerlink" title="7.1 索引概念与分类"></a>7.1 索引概念与分类</h3><p>索引是帮助MySQL高效获取数据的数据结构（有序）；当MySQL查找记录的时候，就可以通过索引及相关的查找算法快速定位到所需信息，无需全表扫描。</p>
<h4 id="7-1-1-索引优劣"><a href="#7-1-1-索引优劣" class="headerlink" title="7.1.1 索引优劣"></a>7.1.1 索引优劣</h4><ul>
<li><strong>优点</strong></li>
</ul>
<ol>
<li><strong>提高数据检索效率</strong>，降低数据库IO成本。</li>
<li>通过索引对数据进行排序，<strong>降低数据排序的成本</strong>，降低CPU的消耗。</li>
</ol>
<ul>
<li><strong>缺点</strong></li>
</ul>
<ol>
<li>索引列需要额外占用存储空间。</li>
<li>降低了更新表（增删改）的速度和效率。</li>
</ol>
<h4 id="7-1-2-按照数据结构划分"><a href="#7-1-2-按照数据结构划分" class="headerlink" title="7.1.2 按照数据结构划分"></a>7.1.2 按照数据结构划分</h4><ul>
<li><strong>索引数据结构分类</strong></li>
</ul>
<table>
<thead>
<tr>
<th>索引结构</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>B+Tree</code>索引</td>
<td>存储引擎 MyISAM 和 InnoDB 实现 B+Tree 索引都是使用 B+Tree，但二者实现方式不一样。MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。</td>
</tr>
<tr>
<td><code>Hash</code>索引</td>
<td>底层通过哈希表（类似于Java中的HashMap）实现。只有精确匹配索引列的查询才有效，不支持范围查询。</td>
</tr>
<tr>
<td><code>R-Tree</code>（空间索引）</td>
<td>是MyISAM引擎的特殊索引类型，主要用于地理空间数据类型（geometry）。通常使用搜索引擎<code>ElasticSearch</code>代替。</td>
</tr>
<tr>
<td><code>Full-text</code>（全文索引）</td>
<td>通过建立倒排索引，快速匹配文档，效率低，使用少。通常使用搜索引擎<code>ElasticSearch</code>代替。</td>
</tr>
</tbody></table>
<ul>
<li><strong>存储引擎支持的索引</strong></li>
</ul>
<table>
<thead>
<tr>
<th>索引</th>
<th><code>InnoDB</code></th>
<th><code>MyISAM</code></th>
<th><code>Memory</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>B+Tree索引</code></td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><code>Hash索引</code></td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><code>R-Tree索引</code></td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><code>Full-text索引</code></td>
<td>支持（5.6版本后）</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h4 id="7-1-3-按照底层存储方式划分"><a href="#7-1-3-按照底层存储方式划分" class="headerlink" title="7.1.3 按照底层存储方式划分"></a>7.1.3 按照底层存储方式划分</h4><ul>
<li><strong>聚簇索引</strong></li>
</ul>
<p>索引和实际数据“簇”在一起，叶子节点就是完整的数据行。</p>
<ul>
<li><strong>非聚簇索引</strong></li>
</ul>
<p>索引结构和数据分开存放的索引，往往根据索引结构查到的数据并非直接是记录（ROW）的数据，还需要经过额外的步骤进行查询。</p>
<h4 id="7-1-4-按照字段特性划分"><a href="#7-1-4-按照字段特性划分" class="headerlink" title="7.1.4 按照字段特性划分"></a>7.1.4 按照字段特性划分</h4><ul>
<li><strong>主键索引</strong></li>
</ul>
<p>建立关于表中主键的索引，默认自动创建，一个表只能有一个主键索引。</p>
<ul>
<li><strong>唯一索引</strong></li>
</ul>
<p>建立关于表中<code>UNIQUE</code>修饰的字段的索引，一个表可以有多个唯一索引。</p>
<ul>
<li><strong>普通索引</strong></li>
</ul>
<p>普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为<code>UNIQUE</code>。</p>
<ul>
<li><strong>前缀索引</strong></li>
</ul>
<p>在<code>VARCHAR</code>、<code>CHAR</code>类型的字段上建立索引时，如果文本的值较长，则会导致索引较大；可以指定使用文本的前<code>n</code>个值建立索引，称为前缀索引。</p>
<h4 id="7-1-5-按照使用字段的数量划分"><a href="#7-1-5-按照使用字段的数量划分" class="headerlink" title="7.1.5 按照使用字段的数量划分"></a>7.1.5 按照使用字段的数量划分</h4><ul>
<li><strong>单列索引</strong></li>
</ul>
<p>使用一个字段建立的索引。</p>
<ul>
<li><strong>联合索引</strong></li>
</ul>
<p>使用多个字段建立的索引，建立索引时多个字段之间的排列顺序对于联合索引的效果是有影响的。</p>
<blockquote>
<p>在业务场景中，如果存在多个查询条件，建议针对查询字段优先建立联合索引，而非单独建立多个单列索引。</p>
</blockquote>
<h3 id="7-2-InnoDB索引实现"><a href="#7-2-InnoDB索引实现" class="headerlink" title="7.2 InnoDB索引实现"></a>7.2 <code>InnoDB</code>索引实现</h3><ol>
<li><strong>从数据结构角度，选用B+树索引作为存储结构：</strong></li>
</ol>
<ul>
<li><strong>改良B+树</strong></li>
</ul>
<p>以<code>InnoDB</code>实现的B+树索引为例，其在数据结构中B+树的基础结构上进行了部分改良，包括：</p>
<ol>
<li>叶子节点之间组成双向链表。</li>
<li>每个节点都对应着<code>InnoDB</code>逻辑存储结构中的页（数据页，Page）。</li>
</ol>
<p>在B+树的结构中，只有叶子节点存放数据，非叶子节点仅存放key和指针。</p>
<p>当具体搜索某条数据时，通过B+树的索引结构，定位到叶节点中的某个数据页，在数据页中进行查询。</p>
<p>当搜索某个范围内的数据时，通过B+树的索引结构，定位到范围下界所在的数据页，在数据页中定位到相应记录后，按序访问双向链表即可获取指定范围内的所有记录。</p>
<ul>
<li><strong><code>InnoDB</code>数据页详解</strong></li>
</ul>
<p>在学习<code>InnoDB</code>存储引擎时，曾提到其<a href="#631-%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">逻辑存储结构</a>。其中，页（16K）是磁盘I&#x2F;O操作的最小单元，也是B+树索引的节点组成，具体包含以下几个部分：</p>
<p><img src="/img/MySQL-Notes/innodb-page-structure.png" srcset="/img/loading.gif" lazyload></p>
<p>其中每部分的作用如下所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>文件头 <code>File Header</code></td>
<td>表示页的信息，包含两个指针，分别指向上一个数据页和下一个数据页，连接起来的数据页组成<strong>双向链表</strong>。</td>
</tr>
<tr>
<td>页头 <code>Page Header</code></td>
<td>表示页的状态信息，负责指导这页在 B+ 树中的位置和角色，如当前页的B+树层级、本页属于哪个索引等。</td>
</tr>
<tr>
<td>最小和最大记录 <code>Infimum</code> <code>Supremum</code></td>
<td>两个虚拟的伪记录，分别表示页中的最小记录和最大记录</td>
</tr>
<tr>
<td>用户记录 <code>User Records</code></td>
<td>存储<strong>行记录</strong>内容</td>
</tr>
<tr>
<td>空闲空间 <code>Free Space</code></td>
<td>存储该页中未被使用的空间</td>
</tr>
<tr>
<td>页目录 <code>Page Directory</code></td>
<td>存储用户记录的相对位置，对记录起到索引作用</td>
</tr>
<tr>
<td>文件尾 <code>File Tailer</code></td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<blockquote>
<p><code>File Header</code>中的两个指针及其构成的双向链表并非B+树底层叶子节点的指针和双向链表，这里的指针和双向链表是一个区为了便于管理自己所拥有的页而建立的。</p>
</blockquote>
<p>在一个数据页内，<strong>最小记录（伪记录）、用户记录、最大记录（伪记录）按照索引键顺序构成一条单向链表</strong>，为加快在页内的查找效率，将单向链表<strong>分组</strong>，同时在页目录中建立槽（slot），<strong>每个槽指向一个分组中的最大记录</strong>。如下图所示：</p>
<p><img src="/img/MySQL-Notes/innodb-page.png" srcset="/img/loading.gif" lazyload></p>
<p>在一个数据页内查找数据的方式：首先通过二分法定位到槽，然后遍历槽内的记录，找到指定记录。</p>
<ol start="2">
<li><strong>从底层存储方式角度</strong></li>
</ol>
<p><code>InnoDB</code>中的索引既有聚簇索引、也有非聚簇索引。</p>
<p><strong>聚簇索引</strong>：如<code>InnoDB</code>中的主键索引，使用主键作为key，在B+树的叶子节点的数据部分，即对应的<code>ROW</code>数据，此为聚簇索引。</p>
<blockquote>
<p><code>InnoDB</code>引擎要求必须包含聚簇索引：</p>
<ul>
<li>如果存在主键，主键索引即为聚簇索引；</li>
<li>如果不存在主键，将使用第一个唯一索引作为聚簇索引；</li>
<li>如果不存在主键、也不存在唯一索引，则<code>InnoDB</code>会自动生成一列<code>rowid</code>作为隐藏的聚簇索引。</li>
</ul>
</blockquote>
<p><strong>非聚簇索引</strong>：<code>InnoDB</code>中根据非主键字段建立的索引，使用非主键字段作为key，在B+树的叶子节点的数据部分，对应的是相应记录在聚簇索引中的<strong>主键值&#x2F;聚簇索引所用的键值</strong>，此为非聚簇索引。在<code>InnoDB</code>的术语中，通常称之为<strong>二级索引&#x2F;辅助索引</strong>。</p>
<blockquote>
<ol>
<li>之所以<code>InnoDB</code>引擎要求必须包含聚簇索引，是因为<code>InnoDB</code>在使用非聚簇索引查询后，如果查询的字段不是主键字段、建立索引的字段，则会根据主键字段在聚簇索引中查询完整记录得到对应字段值，这是<code>InnoDB</code>中<strong>回表查询</strong>的体现。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>如果在二级索引中，建立索引的字段和主键能够覆盖<code>SELECT</code>语句中查询的全部字段，则称为<strong>覆盖索引</strong>，此时就不需要进行回表查询了。</li>
</ol>
</blockquote>
<h3 id="7-3-索引语法与使用"><a href="#7-3-索引语法与使用" class="headerlink" title="7.3 索引语法与使用"></a>7.3 索引语法与使用</h3><ul>
<li><strong>创建索引</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [<span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT] INDEX index_name<br><span class="hljs-keyword">ON</span> table_name(col_name [<span class="hljs-keyword">ASC</span> <span class="hljs-keyword">DESC</span>], ....); <br></code></pre></td></tr></table></figure>

<blockquote>
<p>排序的选项默认为ASC，在对使用<code>ORDER BY</code>的语句优化时会用到。 </p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 前缀索引建立</span><br><span class="hljs-keyword">CREATE</span> INDEX idx_name<br><span class="hljs-keyword">ON</span> table_name(col_name(n));<br><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>查看索引</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX<br><span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>删除索引</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>SQL提示</strong></li>
</ul>
<p>在执行SQL语句的时候，MySQL优化器会自动选择它认为最好的方案执行SQL语句，如果要强制MySQL通过某条索引执行语句，可以使用下列语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name USE INDEX(idx_name) <span class="hljs-keyword">WHERE</span> ...; <span class="hljs-comment">-- 建议MySQL使用（未必一定会使用）</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name IGNORE INDEX(idx_name) <span class="hljs-keyword">WHERE</span> ...; <span class="hljs-comment">-- 忽略某个索引</span><br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> table_name FORCE INDEX(idx_name) <span class="hljs-keyword">WHERE</span> ...; <span class="hljs-comment">-- 强制使用某个索引</span><br></code></pre></td></tr></table></figure>

<h3 id="7-4-SELECT性能分析"><a href="#7-4-SELECT性能分析" class="headerlink" title="7.4 SELECT性能分析"></a>7.4 <code>SELECT</code>性能分析</h3><h4 id="7-4-1-SQL执行频率"><a href="#7-4-1-SQL执行频率" class="headerlink" title="7.4.1 SQL执行频率"></a>7.4.1 SQL执行频率</h4><p>查看增删改查相应的SQL语句在全局&#x2F;当前会话中，在当前数据库中执行的次数。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>下划线有7条。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>这样做的意义是：索引有助于优化以<code>SELECT</code>语句为主的数据库。</li>
</ol>
</blockquote>
<h4 id="7-4-2-SQL慢查询日志"><a href="#7-4-2-SQL慢查询日志" class="headerlink" title="7.4.2 SQL慢查询日志"></a>7.4.2 SQL慢查询日志</h4><p>可以参考<a href="#834-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97">慢查询日志</a>，慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p>
<p>慢查询日志默认没有开启，可以通过以下指令查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;slow_query_log&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>需要在MySQL的配置文件<code>/etc/my.cnf</code>（Linux上）配置如下信息：</p>
<blockquote>
<p>注意不同Linux版本可能的配置文件路径不同，<code>Ubuntu</code>上是在 <code>/etc/mysql/mysql.conf.d/mysqld.cnf</code> 上进行修改。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启MySQL慢日志查询开关</span><br>slow_query_log=1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置慢日志的时间为2秒，SQL语句执行时间超过2秒，则会被视为慢查询，记录慢查询日志</span><br>long_query_time=2<br></code></pre></td></tr></table></figure>

<p>配置完成重启MySQL服务器后，可以查看<code>/var/lib/mysql/localhost-slow.log</code>，其会记录下自定义条件下的慢查询。</p>
<blockquote>
<p><code>Ubuntu</code>上的保存路径是在<code>/var/lib/mysql/hostname-slow.log</code>，其中<code>hostname</code>是主机名。</p>
</blockquote>
<h4 id="7-4-3-profile详情"><a href="#7-4-3-profile详情" class="headerlink" title="7.4.3 profile详情"></a>7.4.3 profile详情</h4><p>查看当前MySQL是否支持<code>profile</code>操作：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@have_profiling</span><br></code></pre></td></tr></table></figure>

<p>如果支持，默认<code>profiling</code>是关闭的，可以通过<code>set</code>语句在session&#x2F;global级别开启profiling。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@profiling</span>; <span class="hljs-comment">-- 默认为0</span><br><span class="hljs-keyword">SET</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>打开profile之后，可以执行一系列SQL操作，通过如下指令可以查看指令的执行耗时：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看每一条SQL的耗时基本情况</span><br><span class="hljs-keyword">SHOW</span> PROFILES;<br><br><span class="hljs-comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况</span><br><span class="hljs-keyword">SHOW</span> PROFILES <span class="hljs-keyword">FOR</span> QUERY query_id;<br><br><span class="hljs-comment">-- 查看指定query_id的SQL语句CPU的使用情况</span><br><span class="hljs-keyword">SHOW</span> PROFILE CPU <span class="hljs-keyword">FOR</span> QUERY query_id;<br><br></code></pre></td></tr></table></figure>
<h4 id="7-4-4-EXPLAIN执行计划"><a href="#7-4-4-EXPLAIN执行计划" class="headerlink" title="7.4.4 EXPLAIN执行计划"></a>7.4.4 <code>EXPLAIN</code>执行计划</h4><p><code>EXPLAIN</code>执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">EXPLAIN SELECT.... ;<br></code></pre></td></tr></table></figure>

<p>通过该语句，数据库会返回一张具有多个字段的表，记录的是针对当前的查询语句的具体执行流程，其中包含的字段及含义：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td>SELECT查询的序列标识符</td>
</tr>
<tr>
<td><code>select_type</code></td>
<td>SELECT关键字对应的查询类型</td>
</tr>
<tr>
<td><code>table</code></td>
<td>用到的表名</td>
</tr>
<tr>
<td><code>type</code></td>
<td>表的访问方法</td>
</tr>
<tr>
<td><code>possible_keys</code></td>
<td>可能用到的索引</td>
</tr>
<tr>
<td><code>key</code></td>
<td>实际用到的索引</td>
</tr>
<tr>
<td><code>key_len</code></td>
<td>所选索引的长度</td>
</tr>
<tr>
<td><code>ref</code></td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td><code>rows</code></td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td><code>filtered</code></td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td><code>Extra</code></td>
<td>附加信息</td>
</tr>
</tbody></table>
<p><strong>id</strong>: id 如果相同，从上往下依次执行；id 不同，id 值越大，执行优先级越高。如果行引用其他行的并集结果，则该值可以为 NULL。</p>
<p><strong>select_type</strong>: 查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>
<ol>
<li>SIMPLE：简单查询，不包含UNION或者子查询。</li>
<li>PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT将被标记为PRIMARY。</li>
<li>SUBQUERY：子查询中的第一个SELECT。</li>
<li>UNION：在UNION语句中，UNION之后出现的SELECT。</li>
<li>DERIVED：在FROM中出现的子查询将被标记为 DERIVED。</li>
<li>UNION RESULT：UNION 查询的结果。</li>
</ol>
<p><strong>table</strong>: 查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>
<ol>
<li><code>&lt;unionM,N&gt;</code> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>
<li><code>&lt;derivedN&gt;</code> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。</li>
<li><code>&lt;subqueryN&gt;</code> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>
</ol>
<p><strong>type(重要)</strong>：查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：</p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>常见的几种类型具体含义如下：</p>
<ol>
<li>system：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>
<li>const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>
<li>eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>
<li>ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>
<li>index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>
<li>range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li>
<li>index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>
<li>ALL：全表扫描。</li>
</ol>
<p><strong>possible_keys</strong>: possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>
<p><strong>key（重要）</strong>：key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p>
<p><strong>key_len</strong>: key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>
<p><strong>rows</strong>: rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>
<p><strong>Extra（重要）</strong>：这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>
<ol>
<li>Using filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>
<li>Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>
<li>Using index：表明查询使用了覆盖索引，<strong>不用回表</strong>，查询效率非常高。</li>
<li>Using index condition：表示查询优化器选择使用了索引条件下推这个特性。</li>
<li>Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>
<li>Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>
</ol>
<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>
<h3 id="7-5-索引失效"><a href="#7-5-索引失效" class="headerlink" title="7.5 索引失效"></a>7.5 索引失效</h3><p>索引失效的核心逻辑就在于，在某些条件下，数据库无法利用B+树的有序性进行高效搜索，从而导致索引失效。</p>
<ul>
<li><strong>对索引列使用计算&#x2F;函数</strong></li>
</ul>
<p>假设<code>id</code>为主键，则以下操作会导致索引失效：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> id <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-operator">=</span> <span class="hljs-number">9</span>; <span class="hljs-comment">-- 对索引列进行了计算</span><br></code></pre></td></tr></table></figure>

<p>假设在<code>t_user</code>表的<code>name</code>字段建立了一个二级索引，则以下操作会导致索引失效：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> LENGTH(name) <span class="hljs-operator">=</span> <span class="hljs-number">6</span>; <span class="hljs-comment">-- 对于索引列使用了函数</span><br></code></pre></td></tr></table></figure>

<p>这都是因为建立的索引是针对指定列的值构建的B+树，而非使用计算&#x2F;函数后的值，因此无法在B+树中进行搜索。</p>
<ul>
<li><strong>对索引使用左模糊匹配</strong></li>
</ul>
<p>在使用<code>LIKE</code>关键词的时候，如果模糊匹配的对象包含左边，如<code>LIKE %ABC</code>、<code>LIKE %ABC%</code>，都会导致索引失效。</p>
<p>因为B+树构建时是按照从左到右的顺序比较指定列（如<code>VARCHAR</code>类型的<code>name</code>），在左侧进行模糊匹配的情况下，无法通过树形的结构找出所有可能匹配的记录。</p>
<ul>
<li><strong>对于VARCHAR类型的字段没有使用<code>&#39;&#39;</code>进行包裹</strong></li>
</ul>
<p>如在<code>phone</code>字段（<code>VARCHAR</code>类型）建立索引后进行查找，如果没有使用<code>&#39;&#39;</code>，会导致索引失效。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> phone <span class="hljs-operator">=</span> <span class="hljs-number">123456789</span>;<br></code></pre></td></tr></table></figure>

<p>根本原因在于，由于<code>phone</code>字段是<code>VARCHAR</code>类型的，此时提供的值为int类型；而在mysql中，字符串会隐式转换为数值类型，数值类型并不会隐式转换为字符串类型；因此，在这里会对<code>phone</code>字段进行类型转换，相当于在这个建立了索引的字段上作用了函数，导致索引失效。</p>
<ul>
<li><strong>联合索引失效情况</strong></li>
</ul>
<p>在使用联合索引的情况中，需要遵循<strong>最左匹配原则</strong>，否则会导致索引失效&#x2F;部分失效。</p>
<p>如在(a, b, c)三个字段上使用了联合索引（注意<strong>和顺序有关</strong>），以下的sql语句可以正确使用索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">-- 部分索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 部分索引</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">-- 部分索引</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意，在以上的<code>WHERE</code>语句中<code>a</code>、<code>b</code>、<code>c</code>三个字段的<strong>出现顺序并不重要，只需要出现就可以</strong>，MySQL会自动优化。</p>
</blockquote>
<p>但如果<code>WHERE</code>语句中某个字段未出现，则在联合索引的建立顺序中，该字段前方的字段能够正常使用索引，该字段后方的字段哪怕出现在<code>WHERE</code>语句中，也不会使用索引（<strong>索引截断</strong>）。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <span class="hljs-comment">-- 不会使用索引，因为联合索引中a没有出现，后方索引都失效</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">-- 不会使用索引，因为联合索引中a没有出现，后方索引都失效</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> b <span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">AND</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">-- 不会使用索引，因为联合索引中a没有出现，后方索引都失效</span><br></code></pre></td></tr></table></figure>

<p>对于索引截断的情况，不同的MySQL版本有不同的处理方式。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> t_user <span class="hljs-keyword">WHERE</span> a <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> c <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure>
<p>MySQL 5.5及之前：在存储引擎层，<code>a</code>通过索引查找到主键，<strong>回表查询</strong>到完整数据行，返回服务层；在服务层中对返回的数据中<code>c</code>的字段进行比较。</p>
<p>MySQL 5.6及之后：在存储引擎层，通过<code>a</code>字段查找索引的过程中，对索引包含的字段先做判断，<strong>直接过滤掉不满足条件的记录</strong>，返回服务层。即会使用<strong>索引下推</strong>的功能：被截断的字段不会在服务层进行判断，而是会被下推到存储引擎层进行条件判断；这样做减少了回表次数，提升了性能。</p>
<blockquote>
<p>在使用<code>EXPLAIN</code>解释<code>SELECT</code>语句时，返回的<code>EXTRA</code>字段中如果有<code>USING INDEX CONDITION</code>，则说明使用了索引下推功能。</p>
</blockquote>
<p>针对联合索引的范围查询，如果在某个字段的筛选条件中出现<code>&gt;</code>或<code>&lt;</code>，则<strong>该字段的后方字段</strong>的索引会失效。这是因为联合索引构建的B+树是<strong>依次比较字段的值</strong>，如果某个字段出现了<code>&gt;</code>或<code>&lt;</code>，则后面的字段就无法保证有序了。</p>
<blockquote>
<p>如果是<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>及<code>前缀匹配LIKE</code>，则不会导致索引失效。</p>
</blockquote>
<ul>
<li><strong><code>WHERE</code>子句中的<code>OR</code></strong></li>
</ul>
<p><code>OR</code>两侧的查询条件如果有一侧字段建立了索引，另一侧字段未建立索引，则会导致建立索引的字段不会通过索引进行查询。</p>
<p>如果都建立了索引，则会分别根据两个索引进行查找，再将结果进行合并。使用<code>EXPLAIN</code>解释类似语句的时候，会发现<code>type</code>的值为<code>index merge</code>。</p>
<h3 id="7-6-常见SQL优化技巧"><a href="#7-6-常见SQL优化技巧" class="headerlink" title="7.6 常见SQL优化技巧"></a>7.6 常见SQL优化技巧</h3><p>在<a href="#74-select%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90">SELECT性能分析</a>章节中，主要针对的是<code>SELECT</code>语句的性能优化，本章主要介绍对于增删改语句的优化。</p>
<h4 id="7-6-1-INSERT优化"><a href="#7-6-1-INSERT优化" class="headerlink" title="7.6.1 INSERT优化"></a>7.6.1 <code>INSERT</code>优化</h4><ol>
<li>批量插入</li>
</ol>
<p>在一条<code>INSERT</code>语句中插入多条记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT INTO</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">VALUES</span> (...), (...), (...);<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>手动提交事务</li>
</ol>
<p>在进行<code>INSERT</code>操作前，手动开启事务，在所有插入语句结束后，手动提交事务；避免系统自动频繁地开启、提交事务。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><span class="hljs-comment">-- A LOT OF INSERT...</span><br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>按照主键顺序递增插入</li>
</ol>
<p>如果乱序插入，可能会导致频繁的页分裂，降低性能，可以参考<a href="#762-%E4%B8%BB%E9%94%AE%E4%BC%98%E5%8C%96">主键优化</a>。</p>
<ol start="4">
<li>大批量数据插入使用<code>LOAD</code></li>
</ol>
<p>一次性插入大批量的数据，可以使用<code>LOAD</code>语句直接将写有大量数据的本地文件传入数据库中的对应表中。</p>
<p><strong>本地文件结构</strong>：包含有多条按序存储的记录，字段之间可以自定义分隔符（如<code>,</code>），记录之间也需要自定义分隔符（如<code>\n</code>）。</p>
<p>在连接MySQL服务端时，加上参数<code>--local-infile</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql --local-infile -u root -p<br></code></pre></td></tr></table></figure>

<p>进入MySQL后，设置全局参数<code>local_infile</code>为1；</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>接下来，可以执行<code>load</code>指令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">LOAD DATA <span class="hljs-keyword">LOCAL</span> INFILE <span class="hljs-string">&#x27;path/to/infile&#x27;</span><br><span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> table_name<br>FIELDS TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;,&#x27;</span> <span class="hljs-comment">-- 指定字段分隔符</span><br>LINES TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">-- 指定记录分隔符</span><br></code></pre></td></tr></table></figure>

<h4 id="7-6-2-主键优化"><a href="#7-6-2-主键优化" class="headerlink" title="7.6.2 主键优化"></a>7.6.2 主键优化</h4><p>在<code>InnoDB</code>中，聚集索引以主键作为<code>key</code>构建B+树，其每个节点为一个数据页（page）。B+树的叶子节点构成双向链表，在每个叶子节点中，即数据页中，存放着多行（ROW）记录，这些记录按照主键的顺序<strong>有序排列</strong>，这就导致整个B+树的底层节点可以看成是按照主键大小顺序排列的链表，可以参考<a href="#72-innodb%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B0">InnoDB索引详解</a>。</p>
<ul>
<li><strong>页分裂</strong></li>
</ul>
<p>由于数据页的大小是固定的（16K），如果乱序插入主键，而插入的位置正好在先前已经装满数据的页中，那么就会出现<strong>页分裂</strong>：MySQL重新申请一块空间作为数据页，将装满的页中的一半数据以及新插入的数据放入新的数据页，重新组织B+树的结构。</p>
<p>因此，乱序插入可能会导致MySQL的额外开销，降低性能。</p>
<ul>
<li><strong>页合并</strong></li>
</ul>
<p>从B+树的某个叶子节点的数据页中删除一行记录时，实际上记录并没有被物理删除，而是被标记为删除，其空间允许被其他记录占用。</p>
<p>当某个数据页中删除的记录达到参数<code>MERGE_THRESHOLD</code>时，<code>InnoDB</code>会开始寻找最靠近的页（前或后），查看是否可以将两个页的记录合并到一个页中。</p>
<ul>
<li><strong>主键设计原则</strong></li>
</ul>
<ol>
<li>满足业务需求的情况下，尽量减低主键的长度。</li>
</ol>
<p><code>InnoDB</code>中所有二级索引的叶子节点都存放记录对应的主键值，主键越长，所有索引都更大、更占内存、更慢。</p>
<ol start="2">
<li><p><strong>插入数据时，尽量选择顺序插入</strong>，选择使用AUTO_INCREMENT自增主键。</p>
</li>
<li><p>尽量不要使用UUID做主键或者是其他自然主键，如身份证号等。</p>
</li>
<li><p>业务操作时，避免对主键的修改。</p>
</li>
</ol>
<h4 id="7-6-3-ORDER-BY优化"><a href="#7-6-3-ORDER-BY优化" class="headerlink" title="7.6.3 ORDER BY优化"></a>7.6.3 <code>ORDER BY</code>优化</h4><p>在<code>EXPLAIN</code>使用<code>ORDER BY</code>语句的<code>SELECT</code>语句时，在<code>EXTRA</code>字段可能会出现<code>Using filesort</code>。</p>
<blockquote>
<p><code>Using filesort</code>: 通过表的索引或全表扫描，读取满足条件的数据行，然后在 <strong>排序缓冲区（sort buffer）</strong> 中完成排序操作，所有不是通过索引直接返回排序结果的排序都属于这一类。（效率低）</p>
</blockquote>
<p><strong>使用索引优化</strong>：如果可以通过索引<strong>直接读取到相关的有序数据</strong>（因为B+树底层的双向链表是根据<code>key</code>的大小关系进行排列的），那么就不需要额外的排序操作，可以直接返回，这种情况下效率高。</p>
<blockquote>
<p>问题的关键就在于索引构建的B+树的底层节点的排序顺序与<code>ORDER BY</code>要求的是否一致，如果一致，则不会额外进行排序。</p>
</blockquote>
<ul>
<li><strong>ORDER BY 单一字段</strong></li>
</ul>
<p>此时，只要在该字段上存在索引，在不存在索引失效的情况下，可以直接读取到相关的有序数据。降序&#x2F;升序都可以，因为底层是双向链表，两个方向都可以按序访问。</p>
<ul>
<li><strong>ORDER BY 多个字段</strong></li>
</ul>
<p>此时，按照联合索引进行访问的话，要求多个字段的排序方式一致（都为降序或升序），那么在联合索引未失效的情况下，可以直接在索引中查询到有序数据并返回。</p>
<p>如果多个字段的排序方式不同，那么在建立联合索引的时候，其字段的排序方式应该与<code>ORDER BY</code>中一致，否则无法通过索引直接返回有序数据，需要经过额外的排序。</p>
<blockquote>
<ol>
<li>是否通过索引直接返回有序数据与是否为覆盖索引（是否回表）无关。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>是否回表只影响是否出现 Using index，不直接决定会不会 Using filesort，但优化器在“选索引 + 回表成本 + 是否 filesort”之间会做代价权衡。</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>在<code>ORDER BY</code>中也要符合联合索引的最左匹配原则，否则会失效。</li>
</ol>
</blockquote>
<h4 id="7-6-4-GROUP-BY优化"><a href="#7-6-4-GROUP-BY优化" class="headerlink" title="7.6.4 GROUP BY优化"></a>7.6.4 <code>GROUP BY</code>优化</h4><p>在<code>EXPLAIN</code>使用<code>GROUP BY</code>语句的<code>SELECT</code>语句时，在<code>EXTRA</code>字段可能会出现<code>Using temporary</code>。</p>
<blockquote>
<p><code>Using temporary</code>：说明产生了临时表用来存储信息，效率低。</p>
</blockquote>
<p><strong>使用索引优化</strong>：可以通过建立索引，这样让某个字段值相同的数据会优先存放在一起，这样返回的数据本身就是已经分好组的了，不需要使用临时表了。</p>
<blockquote>
<ol>
<li><code>GROUP BY</code>和<code>ORDER BY</code>两者的优化思路非常相似，可以参考上面的<code>ORDER BY</code>的思路进行一个类比。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li><code>GROUP BY</code>在使用联合索引进行优化时，同样需要遵循最左匹配原则。</li>
</ol>
</blockquote>
<h4 id="7-6-5-LIMIT优化"><a href="#7-6-5-LIMIT优化" class="headerlink" title="7.6.5 LIMIT优化"></a>7.6.5 <code>LIMIT</code>优化</h4><p>当<code>LIMIT a, b</code>中<code>a</code>参数较大时，查询的效率会很低。</p>
<p><strong>覆盖索引+子查询优化</strong>：首先在子查询中按照某种排序方式找到对应分页指定的数据的主键（覆盖索引），然后将该子查询作为表与原表进行连接，查找指定的字段。</p>
<p>例如在<code>user</code>中，按照<code>name</code>排序后，找出索引数从20000开始的10行数据，<code>user</code>表中<code>id</code>为主键。</p>
<p>首先根据<code>name</code>建立索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX idx_name <span class="hljs-keyword">ON</span> <span class="hljs-keyword">user</span>(name);<br></code></pre></td></tr></table></figure>

<p>构建子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> id<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> name<br>LIMIT <span class="hljs-number">20000</span>, <span class="hljs-number">10</span>;<br><span class="hljs-comment">-- 这样的话</span><br></code></pre></td></tr></table></figure>

<p>最终查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.<span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span> s, (<br>  <span class="hljs-keyword">SELECT</span> id<br>  <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">user</span><br>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> name<br>  LIMIT <span class="hljs-number">20000</span>, <span class="hljs-number">10</span><br>) t<br><span class="hljs-keyword">WHERE</span> s.id <span class="hljs-operator">=</span> t.id;<br><br></code></pre></td></tr></table></figure>

<h4 id="7-6-6-COUNT优化"><a href="#7-6-6-COUNT优化" class="headerlink" title="7.6.6 COUNT优化"></a>7.6.6 <code>COUNT</code>优化</h4><p>聚合函数<code>COUNT</code>通过读取指定的字段值，返回读取的记录中指定字段不为<code>null</code>的个数。</p>
<p>数据库的服务层维护一个值<code>count</code>作为<code>COUNT</code>的结果。在<code>InnoDB</code>引擎中，每次从引擎中返回一条非空记录，<code>count</code>加1，动态维护，速度慢；在<code>MyISAM</code>引擎中，<code>count</code>作为元数据可直接返回，速度快。</p>
<p><strong>先说结论</strong>，效率排名：<code>COUNT(*)</code> &#x3D; <code>COUNT(1)</code> &gt; <code>COUNT(主键)</code> &gt; <code>COUNT(字段)</code>。</p>
<ul>
<li><strong>COUNT(字段)</strong></li>
</ul>
<p>如果在该字段上没有<code>not null</code>约束，则会从二级索引（如果在指定字段上存在）扫描&#x2F;全表扫描（聚簇索引），并且取出字段值，在服务层中会对其进行是否为空的判断，计数累加。</p>
<p>如果在该字段上有<code>not null</code>约束，则会从二级索引（如果在指定字
段上存在）扫描&#x2F;全表扫描（聚簇索引），并且取出字段值，在服务层中直接计数累加。</p>
<blockquote>
<ol>
<li>这里的字段指的是非主键。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>MySQL优化器优先通过二级索引进行扫描，这是因为二级扫描中每个节点存储的值更少，IO开销小。同样的逻辑可以推出：如果有多个二级索引，优化器会优先选择键长更短的二级索引。</li>
</ol>
</blockquote>
<ul>
<li><strong>COUNT(主键)</strong></li>
</ul>
<p>从二级索引（如果存在）&#x2F; 聚簇索引（如果不存在二级索引）扫描，读取ID值&#x2F;记录中的ID值，返回服务层，直接计数累加。</p>
<blockquote>
<ol>
<li>由于主键自身含有<code>NOT NULL</code>的约束，因此服务层不需要判断。</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>优先选取二级索引的原因也与IO有关。</li>
</ol>
</blockquote>
<ul>
<li><strong>COUNT(1)和COUNT(*)</strong></li>
</ul>
<p>MySQL对于<code>COUNT(*)</code>做了优化，其实际效果与<code>COUNT(1)</code>差不多。</p>
<p>从二级索引（如果存在）&#x2F;聚簇索引（如果不存在二级索引）扫描，不取值，返回服务层，直接计数累加。</p>
<h4 id="7-6-7-UPDATE优化"><a href="#7-6-7-UPDATE优化" class="headerlink" title="7.6.7 UPDATE优化"></a>7.6.7 <code>UPDATE</code>优化</h4><p>这里主要是针对于<code>UPDATE</code>语句处理不当时，可能会导致行锁失效成为“表锁”。</p>
<p>需要理解<code>InnoDB</code>的锁机制是基于索引的，如果并发事务中，条件语句中的字段没有索引，则会在聚簇索引上扫描所有的记录，这样都会被上行锁，看上去就好像变成了表锁。</p>
<p>例如，在如下这张表上：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> <span class="hljs-keyword">user</span> (<br>    id     <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY KEY</span>,<br>    name   <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>),<br>    age    <span class="hljs-type">INT</span>,<br>    INDEX idx_age(age)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB;<br><br></code></pre></td></tr></table></figure>

<p>开启一个事务，执行如下<code>UPDATE</code>语句:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务 A</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Alice&#x27;</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>;<br></code></pre></td></tr></table></figure>

<p>此时，在<code>age</code>字段上存在二级索引，锁机制就会精准定位到该二级索引中<code>age=18</code>的这一小部分记录；其他<code>age != 18</code>的行在别的事务中可以进行更新，也就是<strong>行锁</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务B</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">19</span>; <span class="hljs-comment">-- ok</span><br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Cat&#x27;</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">=</span> <span class="hljs-number">18</span>; <span class="hljs-comment">-- 得不到锁</span><br></code></pre></td></tr></table></figure>

<p>但如果，是这样的<code>UPDATE</code>语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 事务A，没有给 name 建索引</span><br><span class="hljs-keyword">BEGIN</span>;<br><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> age <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Bob&#x27;</span>;<br><br></code></pre></td></tr></table></figure>

<p>由于在<code>name</code>上没有索引，所以事务A只能扫描聚簇索引，一个一个比对各条记录的<code>name</code>字段，<strong>每个被扫描的记录都会被上锁</strong>，因此看上去就好像成为了表锁，可以参考之前<a href="#533-%E8%A1%8C%E7%BA%A7%E9%94%81">行级锁</a>的相关内容。</p>
<blockquote>
<p>注意，这个行为是在默认的隔离级别<code>RR</code>下的实现，在<code>RC</code>隔离级别下的实现有所不同。</p>
</blockquote>
<h3 id="7-7-索引使用原则"><a href="#7-7-索引使用原则" class="headerlink" title="7.7 索引使用原则"></a>7.7 索引使用原则</h3><ol>
<li><p>针对于<strong>数据量大、查询频繁</strong>的表建立索引。</p>
</li>
<li><p>针对于常作为查询条件、排序、分组的字段建立索引。</p>
</li>
<li><p>尽量选择区分度高的列作为索引，尽量建立<strong>唯一索引</strong>，区分度越高，使用索引效率越高。</p>
</li>
<li><p>字符串类型的字段，如果字段值较长，可以考虑<strong>前缀索引</strong>。</p>
</li>
<li><p><strong>尽量使用联合索引</strong>，减少单列索引；联合索引常常可以成为<strong>覆盖索引</strong>，节省存储空间、避免回表操作，提高查询效率。</p>
</li>
<li><p>控制<strong>索引的数量</strong>：索引越多，则对于表的增删改的效率就越低，且会占据更多的磁盘空间。</p>
</li>
<li><p>如果索引列不能存储<code>NULL</code>值，在创建表时对该字段使用约束<code>NOT NULL</code>；这样MySQL优化器可以更好地确定哪个索引能最有效用于查询。</p>
</li>
</ol>
<h2 id="8-运维与管理"><a href="#8-运维与管理" class="headerlink" title="8. 运维与管理"></a><strong>8. 运维与管理</strong></h2><h3 id="8-1-系统数据库简介"><a href="#8-1-系统数据库简介" class="headerlink" title="8.1 系统数据库简介"></a>8.1 系统数据库简介</h3><p>MySQL数据库安装完成后，自带以下四个数据库：</p>
<table>
<thead>
<tr>
<th>数据库名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>mysql</code></td>
<td>存储MySQL服务器正常运行所需要的各种信息（时区、主从、用户、权限等）。</td>
</tr>
<tr>
<td><code>information_schema</code></td>
<td>提供了访问数据库元数据的各种表和视图，包含数据库、表、字段类型及访问权限等。</td>
</tr>
<tr>
<td><code>perfomance_schema</code></td>
<td>为MySQL服务器运行时状态提供了一个底层监控功能，主要用于收集数据库服务器性能参数。</td>
</tr>
<tr>
<td><code>sys</code></td>
<td>包含了一系列方便数据库管理人员利用<code>perfomance_schema</code>数据库进行性能调优和诊断的视图。</td>
</tr>
</tbody></table>
<h3 id="8-2-常用客户端与管理工具"><a href="#8-2-常用客户端与管理工具" class="headerlink" title="8.2 常用客户端与管理工具"></a>8.2 常用客户端与管理工具</h3><h4 id="8-2-1-mysql"><a href="#8-2-1-mysql" class="headerlink" title="8.2.1 mysql"></a>8.2.1 <code>mysql</code></h4><p>MySQL的客户端工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql [options] [database]<br><br><span class="hljs-comment"># 选项 ：</span><br><span class="hljs-comment"># -u, --user=name #指定用户名</span><br><span class="hljs-comment"># -p, --password[=name] #指定密码</span><br><span class="hljs-comment"># -h, --host=name #指定服务器IP或域名</span><br><span class="hljs-comment"># -P, --port=port #指定连接端口</span><br><span class="hljs-comment"># -e, --execute=name #执行SQL语句并退出</span><br><br><span class="hljs-comment"># 示例</span><br>mysql -uroot –p123456 db01 -e <span class="hljs-string">&quot;select * from stu&quot;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="8-2-2-mysqladmin"><a href="#8-2-2-mysqladmin" class="headerlink" title="8.2.2 mysqladmin"></a>8.2.2 <code>mysqladmin</code></h4><p><code>mysqladmin</code>是一个执行管理操作的客户端程序。可以用它来检查服务器的配置和当前状态、创建并删除数据库等。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqladmin [options] <span class="hljs-built_in">command</span> ...<br><br><span class="hljs-comment"># 选项：</span><br><span class="hljs-comment"># -u, --user=name #指定用户名</span><br><span class="hljs-comment"># -p, --password[=name] #指定密码</span><br><span class="hljs-comment"># -h, --host=name #指定服务器IP或域名</span><br><span class="hljs-comment"># -P, --port=port #指定连接端口</span><br><br><span class="hljs-comment"># 示例：</span><br>mysqladmin -uroot –p1234 drop <span class="hljs-string">&#x27;test01&#x27;</span>;<br>mysqladmin -uroot –p1234 version;<br></code></pre></td></tr></table></figure>

<h4 id="8-2-3-mysqlbinlog"><a href="#8-2-3-mysqlbinlog" class="headerlink" title="8.2.3 mysqlbinlog"></a>8.2.3 <code>mysqlbinlog</code></h4><p>由于服务器生成的二进制日志文件以二进制格式保存，所以如果想要检查这些文本的文本格式，就会使用到mysqlbinlog 日志管理工具。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqlbinlog [options] log-files1 log-files2 ...<br><br><span class="hljs-comment"># 选项：</span><br><span class="hljs-comment"># -u, --user=name #指定用户名</span><br><span class="hljs-comment"># -p, --password[=name] #指定密码</span><br><span class="hljs-comment"># -d, --database=name # 指定数据库名称，只列出指定的数据库相关操作。</span><br><span class="hljs-comment"># -o, --offset=n #忽略掉日志中的前n行命令。</span><br><span class="hljs-comment"># -r,--result-file=name # 将输出的文本格式日志输出到指定文件。</span><br><span class="hljs-comment"># -s, --short-form # 显示简单格式， 省略掉一些信息。</span><br><span class="hljs-comment"># --start-datatime=date1 --stop-datetime=date2 # 指定日期间隔内的所有日志。</span><br><span class="hljs-comment"># --start-position=pos1 --stop-position=pos2 # 指定位置间隔内的所有日志。</span><br><span class="hljs-comment"># -v #将行事件(数据变更)重构为SQL语句</span><br><span class="hljs-comment"># -vv #将行事件(数据变更)重构为SQL语句，并输出注释信息</span><br></code></pre></td></tr></table></figure>

<h4 id="8-2-4-mysqlshow"><a href="#8-2-4-mysqlshow" class="headerlink" title="8.2.4 mysqlshow"></a>8.2.4 <code>mysqlshow</code></h4><p><code>mysqlshow</code>客户端对象查找工具，用来很快地查找存在哪些数据库、数据库中的表、表中的列或者索引。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqlshow [options] [db_name] [table_name]  [col_name]<br><br><span class="hljs-comment"># 选项 </span><br><span class="hljs-comment"># -u, --user=name #指定用户名</span><br><span class="hljs-comment"># -p, --password[=name] #指定密码</span><br><span class="hljs-comment"># --count # 显示数据库及表的统计信息（数据库，表 均可以不指定）</span><br><span class="hljs-comment"># -i # 显示指定数据库或者指定表的状态信息</span><br><br></code></pre></td></tr></table></figure>

<h4 id="8-2-5-mysqldump"><a href="#8-2-5-mysqldump" class="headerlink" title="8.2.5 mysqldump"></a>8.2.5 <code>mysqldump</code></h4><p><code>mysqldump</code>客户端工具用来备份数据库或在不同数据库之间进行数据迁移。备份内容包含创建表，及插入表的SQL语句。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqldump [options] db_name [tables]<br>mysqldump [options] --database/-B db1 [db2 db3...]<br>mysqldump [options] --all-databases/-A<br><br><span class="hljs-comment"># 选项</span><br><span class="hljs-comment"># -u, --user=name # 指定用户名</span><br><span class="hljs-comment"># -p, --password[=name] #指定密码</span><br><span class="hljs-comment"># -h, --host=name # 指定服务器ip或域名</span><br><span class="hljs-comment"># -P, --port=xxxx #指定连接端口</span><br><span class="hljs-comment"># --add-drop-database # 在每个数据库创建语句前加上 drop database 语句</span><br><span class="hljs-comment"># --add-drop-table # 在每个表创建语句前加上 drop table 语句 , 默认开启 ; 不开启 (--skip-add-drop-table)</span><br><span class="hljs-comment"># -n, --no-create-db # 不包含数据库的创建语句</span><br><span class="hljs-comment"># -t, --no-create-info # 不包含数据表的创建语句</span><br><span class="hljs-comment"># -d --no-data # 不包含数据</span><br><span class="hljs-comment"># -T, --tab=name # 自动生成两个文件：一个.sql文件，创建表结构的语句；一个.txt文件，数据文件</span><br></code></pre></td></tr></table></figure>

<h4 id="8-2-6-mysqlimport和source"><a href="#8-2-6-mysqlimport和source" class="headerlink" title="8.2.6 mysqlimport和source"></a>8.2.6 <code>mysqlimport</code>和<code>source</code></h4><p><code>mysqlimport</code>是客户端数据导入工具，用来导入<code>mysqldump</code>加<code>-T</code>参数后导出的文本文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysqlimport [options] db_name textfile1 [textfile2...]<br><br><span class="hljs-comment"># 选项</span><br><span class="hljs-comment"># -u, --user=name # 指定用户名</span><br><span class="hljs-comment"># -p, --password[=name] #指定密码</span><br><span class="hljs-comment"># -h, --host=name # 指定服务器ip或域名</span><br><span class="hljs-comment"># -P, --port=xxxx #指定连接端口</span><br></code></pre></td></tr></table></figure>

<p><code>source</code>在MySQL客户端中使用，可以直接导入<code>.sql</code>文件。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">source \path\<span class="hljs-keyword">to</span>\xxxx.sql\xxxx.sql;<br></code></pre></td></tr></table></figure>

<h3 id="8-3-日志"><a href="#8-3-日志" class="headerlink" title="8.3 日志"></a>8.3 日志</h3><h4 id="8-3-1-错误日志"><a href="#8-3-1-错误日志" class="headerlink" title="8.3.1 错误日志"></a>8.3.1 错误日志</h4><p>错误日志记录了<strong>MySQL服务器启动和停止时、以及服务器在运行过程中发生任何严重错误时的相关信息</strong>。该日志默认开启，可以按照如下指令查看相关信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%log_error%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="8-3-2-二进制日志"><a href="#8-3-2-二进制日志" class="headerlink" title="8.3.2 二进制日志"></a>8.3.2 二进制日志</h4><p>二进制日志记录了所有的DDL语句和DML语句，可用于灾难时的<strong>数据恢复</strong>和MySQL的<strong>主从复制</strong>。在MySQL8.0版本中，默认二进制日志是开启的，可以按照如下指令查看相关信息：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> VARIABLES <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;<br><br><span class="hljs-comment">-- log_bin_basename: 当前数据库服务器的binlog日志的基础名称，具体的binlog文件名需要在该基础名称上加上编号。</span><br><span class="hljs-comment">-- log_bin_index: binlog的索引文件，记录了当前服务器关联的binlog文件。</span><br><br></code></pre></td></tr></table></figure>
<blockquote>
<p>二进制日志不包含查询（<code>SELECT</code>和<code>SHOW</code>）语句。</p>
</blockquote>
<ul>
<li><strong>格式</strong></li>
</ul>
<p>MySQL服务器提供了多种格式来记录二进制日志，相关参数：<code>binlog_format</code>：</p>
<table>
<thead>
<tr>
<th>日志格式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>STATEMENT</code></td>
<td>记录对数据进行修改的SQL语句</td>
</tr>
<tr>
<td><code>ROW</code></td>
<td>记录每一行的数据变更（默认）</td>
</tr>
<tr>
<td><code>MIXED</code></td>
<td>混合<code>STATEMENT</code>和<code>ROW</code>两种格式，默认采用<code>STATEMENT</code>，在某些特殊情况下会自动切换为<code>ROW</code>进行记录</td>
</tr>
</tbody></table>
<ul>
<li><strong>查看</strong></li>
</ul>
<p>由于二进制日志为二进制文件无法直接读取，可以利用工具<a href="#823-mysqlbinlog">mysqlbinlog</a>使用。</p>
<ul>
<li><strong>删除</strong></li>
</ul>
<p>在MySQL8.0中，默认30天会对二进制日志进行自动删除，通过参数<code>binlog_expire_logs_seconds</code>控制。</p>
<p>此外，也可以通过如下指令手动批量删除二进制日志：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">RESET MASTER; <span class="hljs-comment">-- 删除全部binlog日志，删除后日志编号重新从binlog.000001开始。</span><br><br>PURGE MASTER LOGS <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;binlog.xxxxxx&#x27;</span>; <span class="hljs-comment">-- 删除xxxxxx编号前的所有日志</span><br><br>PURGE MASTER LOGS BEFORE <span class="hljs-string">&#x27;yyyy-mm-dd hh24:mi:ss&#x27;</span>; <span class="hljs-comment">-- 删除在指定日期前产生的所有日志。</span><br></code></pre></td></tr></table></figure>

<h4 id="8-3-3-查询日志"><a href="#8-3-3-查询日志" class="headerlink" title="8.3.3 查询日志"></a>8.3.3 查询日志</h4><p>查询日志记录了客户端的所有操作语句，包括查询语句、数据操作语句等。默认情况下，查询日志并未开启，可查看参数<code>general_log</code>，参数<code>general_log_file</code>指定了查询日志的保存文件（xxx.log）。</p>
<h4 id="8-3-4-慢查询日志"><a href="#8-3-4-慢查询日志" class="headerlink" title="8.3.4 慢查询日志"></a>8.3.4 慢查询日志</h4><p>慢查询日志记录了所有<strong>执行时间超过参数<code>long_query_time</code>、扫描记录数不小于<code>min_examined_row_limit</code>的SQL语句日志</strong>。</p>
<ul>
<li><strong>参数说明</strong><ul>
<li><code>slow_query_log</code>：是否开启慢查询日志（<code>0</code>：未开启，默认；<code>1</code>：开启）。</li>
<li><code>long_query_time</code>: 慢查询的时间阈值，单位为秒（默认为10s）。</li>
<li><code>log_slow_admin_statements</code>：是否记录管理语句（操作数据库服务器本身的语句）中的慢查询语句（<code>0</code>：未开启，默认；<code>1</code>：开启）。</li>
<li><code>log_queries_not_using_indexes</code>: 是否记录未使用索引语句中的慢查询语句（<code>0</code>：未开启，默认；<code>1</code>：开启）。</li>
</ul>
</li>
</ul>
<h2 id="9-高可用与扩展架构"><a href="#9-高可用与扩展架构" class="headerlink" title="9. 高可用与扩展架构"></a><strong>9. 高可用与扩展架构</strong></h2><h3 id="9-1-主从分离"><a href="#9-1-主从分离" class="headerlink" title="9.1 主从分离"></a>9.1 主从分离</h3><h4 id="9-1-1-主从复制概念"><a href="#9-1-1-主从复制概念" class="headerlink" title="9.1.1 主从复制概念"></a>9.1.1 主从复制概念</h4><p>主从复制是指主数据库的DDL和DML操作通过<strong>二进制日志</strong>传到从库服务器中，在从库上对这些日志<strong>重新执行（重做）</strong>，从而使得从库和主库的数据保持同步。MySQL支持一台主库同时向多台从库进行复制，从库同时也可以作为其他从服务器的主库，实现链状复制。</p>
<p><img src="/img/MySQL-Notes/master-to-slave-copy-overview.png" srcset="/img/loading.gif" lazyload alt="主从复制概览图"></p>
<ul>
<li><strong>具体步骤</strong></li>
</ul>
<ol>
<li>主库在事务提交时，把数据变更记录在二进制文件<code>bin log</code>中。</li>
<li>从库读取主库的二进制文件，写入到自身的中继日志<code>relay log</code>中。</li>
<li>从库重做中继日志中的事件，使自身数据与主库保持一致。</li>
</ol>
<ul>
<li><strong>优点</strong></li>
</ul>
<ol>
<li>主库出现问题，可以快速切换到从库提供服务。</li>
<li>实现读写分离，降低主库的访问压力。</li>
<li>可以在从库中执行备份，以避免备份期间影响主库服务。</li>
</ol>
<h4 id="9-1-2-实验复现"><a href="#9-1-2-实验复现" class="headerlink" title="9.1.2 实验复现"></a>9.1.2 实验复现</h4><ul>
<li><strong>主从服务器相关信息</strong></li>
</ul>
<p>主服务器：Windows宿主机，IP地址为<code>10.203.255.46</code>，MySQL服务器端口为3306
从服务器：Linux虚拟机，IP地址为<code>10.0.2.15</code>。</p>
<ul>
<li><strong>配置主服务器</strong></li>
</ul>
<ol>
<li>修改配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 修改MySQL配置文件<br><br>server-id=1 # mysql服务ID，保证整个集群环境中唯一，取值范围：1 ~ 2^32 - 1<br><br>read-only=0 # 1:只读 0：读写<br><br># binlog-ignore-db=xxxx # 不需要同步的数据库<br><br># binlog-do-db=xxxx # 指定同步的数据库<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>重启MySQL服务器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart mysqld <span class="hljs-comment">#Linux</span><br>net start mysql80 <span class="hljs-comment">#windows，或者win+r services.msc 手动重启mysql80</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>创建远程登录账号授予主从复制权限</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;ygh&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> REPLICATION SLAVE <span class="hljs-keyword">ON</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;ygh&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>查看二进制日志坐标</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> MASTER STATUS;<br></code></pre></td></tr></table></figure>

<p>查看从哪个日志文件（<code>File</code>）的哪个位置（<code>Position</code>）开始推送日志。</p>
<p><img src="/img/MySQL-Notes/master-to-slave-copy-demo-1.png" srcset="/img/loading.gif" lazyload alt="主服务器配置示例"></p>
<ul>
<li><strong>配置从服务器</strong></li>
</ul>
<ol>
<li>修改配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 修改MySQL配置文件<br><br>server-id=2 # mysql服务ID，保证整个集群环境中唯一，取值范围：1 ~ 2^32 - 1，与主服务器不同即可<br><br>read-only=1 # 1:只读 0：读写<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>重启MySQL服务器</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart mysql <span class="hljs-comment">#Linux</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>登录mysql,设置主库配置</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- MySQL 8.0.23之后（包括）</span><br>CHANGE REPLICATION SOURCE <span class="hljs-keyword">TO</span> <br>SOURCE_HOST<span class="hljs-operator">=</span><span class="hljs-string">&#x27;10.203.255.46&#x27;</span>,SOURCE_USER<span class="hljs-operator">=</span><span class="hljs-string">&#x27;ygh&#x27;</span>,SOURCE_PASSWORD<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123456&#x27;</span>,<br>SOURCE_LOG_FILE<span class="hljs-operator">=</span><span class="hljs-string">&#x27;JARVIS-bin.000165&#x27;</span>,SOURCE_LOG_POS<span class="hljs-operator">=</span><span class="hljs-number">658</span>;<br><br><span class="hljs-comment">-- MySQL 8.0.23之前</span><br>CHANGE MASTER <span class="hljs-keyword">TO</span> <br>MASTER_HOST<span class="hljs-operator">=</span><span class="hljs-string">&#x27;10.203.255.46&#x27;</span>,MASTER_USER<span class="hljs-operator">=</span><span class="hljs-string">&#x27;ygh&#x27;</span>,MASTER_PASSWORD<span class="hljs-operator">=</span><span class="hljs-string">&#x27;123456&#x27;</span>,<br>MASTER_LOG_FILE<span class="hljs-operator">=</span><span class="hljs-string">&#x27;JARVIS-bin.000165&#x27;</span>,MASTER_LOG_POS<span class="hljs-operator">=</span><span class="hljs-number">658</span>;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>开启同步操作</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> REPLICA; <span class="hljs-comment">-- 8.0.23后（包括）</span><br><span class="hljs-keyword">START</span> SLAVE; <span class="hljs-comment">-- 8.0.23前</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>如要关闭，把<code>START</code>改成<code>STOP</code>即可。</p>
</blockquote>
<ol start="5">
<li>查看主从同步状态</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> REPLICA STATUS; <span class="hljs-comment">-- 8.0.23后（包括）</span><br><span class="hljs-keyword">SHOW</span> SLAVE STATUS; <span class="hljs-comment">-- 8.0.23前</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>测试</strong></li>
</ul>
<ol>
<li>在主服务器上执行一系列操作。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> DATABASE db01;<br>USE db01;<br><span class="hljs-keyword">CREATE TABLE</span> tb_user(<br>  id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">PRIMARY KEY</span> <span class="hljs-keyword">NOT NULL</span> AUTO_INCREMENT,<br>  name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT NULL</span>,<br>  sev <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>)<br>) ENGINE <span class="hljs-operator">=</span> innodb;<br><br><span class="hljs-keyword">INSERT INTO</span> tb_user <span class="hljs-keyword">VALUES</span>(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;ygh&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>),(<span class="hljs-keyword">NULL</span>, <span class="hljs-string">&#x27;ccq&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><img src="/img/MySQL-Notes/master-to-slave-copy-demo-2.png" srcset="/img/loading.gif" lazyload></p>
<ol start="2">
<li>查看从服务器上是否有相应的数据。</li>
</ol>
<p><img src="/img/MySQL-Notes/master-to-slave-copy-demo-3.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="9-2-分库分表"><a href="#9-2-分库分表" class="headerlink" title="9.2 分库分表"></a>9.2 分库分表</h3><ul>
<li><strong>解决问题</strong></li>
</ul>
<p>单数据库如果存储量过多会产生一些问题：</p>
<ol>
<li>IO瓶颈：数据过多，而内存空间有限（缓冲池大小有限），产生大量磁盘IO，效率降低；请求数据太多，带宽不够，网络IO瓶颈。</li>
<li>CPU瓶颈：排序、分组、连接查询、聚合统计等SQL会耗费大量CPU资源，请求数太多，CPU出现瓶颈。</li>
</ol>
<ul>
<li><strong>解决思想</strong></li>
</ul>
<p>分库分表的中心思想即将数据分散存储，使得单一数据库&#x2F;表的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的。</p>
<p>拆分数据的方式大体上可分为<strong>垂直拆分</strong>和<strong>水平拆分</strong>两类：</p>
<ol>
<li><strong>垂直拆分</strong>：会改动单一数据库&#x2F;表的结构，拆分成多个结构不同的数据库&#x2F;表。</li>
<li><strong>水平拆分</strong>：不改动单一数据库&#x2F;表的结构，拆分成多个结构相同的数据库&#x2F;表，只是将记录进行分散存储。</li>
</ol>
<ul>
<li><strong>技术实现</strong></li>
</ul>
<ol>
<li><code>shardingJDBC</code>：基于AOP原理，在应用程序中对本地执行的SQL进行拦截、解析、改写及路由处理；需自行编码配置实现，只支持Java语言，性能较高。</li>
<li><code>MyCat</code>：数据库分库分表中间件，不用调整代码即可实现分库分表，支持多种语言，性能不及前者。</li>
</ol>
<h3 id="9-3-读写分离"><a href="#9-3-读写分离" class="headerlink" title="9.3 读写分离"></a>9.3 读写分离</h3><h4 id="9-3-1-读写分离概念"><a href="#9-3-1-读写分离概念" class="headerlink" title="9.3.1 读写分离概念"></a>9.3.1 读写分离概念</h4><ul>
<li><strong>思想</strong></li>
</ul>
<p>读写分离即将数据库的读和写操作分开，以对应不同的数据库服务器：主服务器提供写操作，从数据库提供读操作。这样能够有效地减轻单台数据库的压力。</p>
<ul>
<li><strong>实现</strong></li>
</ul>
<p>通过中间件（如MyCat）与主从复制完成读写分离的操作；具体来说，应用程序统一访问中间件（如MyCat），后者对<code>SQL</code>语句进行路由（将读写<code>SQL</code>分离），而为了保证数据库数据的一致性，可以通过主从分离（即传递二进制日志文件）实现。</p>
<p><img src="/img/MySQL-Notes/read-write-seperate-overview.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="9-3-2-一主一从读写分离"><a href="#9-3-2-一主一从读写分离" class="headerlink" title="9.3.2 一主一从读写分离"></a>9.3.2 一主一从读写分离</h4><p>使用一台主服务器和一台从服务器，主从服务器之间通过主从复制实现同步、通过中间件分发<code>SQL</code>实现负载均衡。</p>
<p><img src="/img/MySQL-Notes/read-write-seperate-overview.png" srcset="/img/loading.gif" lazyload></p>
<h4 id="9-3-3-双主双从读写分离"><a href="#9-3-3-双主双从读写分离" class="headerlink" title="9.3.3 双主双从读写分离"></a>9.3.3 双主双从读写分离</h4><p>在一主一从读写分离的模式下，如果主服务器宕机，则业务系统就只能读不能写入数据了。提高系统的鲁棒性，可以使用双主双从的架构。</p>
<p><img src="/img/MySQL-Notes/read-write-separate-overview2.png" srcset="/img/loading.gif" lazyload></p>
<p>一个主机<code>m1</code>用于处理写，另外一台主机<code>m2</code>以及两台从机用于处理读；当一台主机宕机的时候，另一台主机处理写，剩余的两台从机用于读。</p>
<hr>
<p><strong>参考学习资源</strong>：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Kr4y1i7ru">黑马程序员: MySQL</a></li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-questions-01.html">JavaGuide: MySQL常见面试题</a></li>
<li><a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/">小林coding: 图解MySQL</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/MySQL/" class="print-no-link">#MySQL</a>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="print-no-link">#数据库</a>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/" class="print-no-link">#后端开发</a>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/" class="print-no-link">#笔记</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/11/26/MH-Net-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" title="MH-Net: 论文阅读笔记">
                        <span class="hidden-mobile">MH-Net: 论文阅读笔记</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
